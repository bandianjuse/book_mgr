/*
Navicat MySQL Data Transfer

Source Server         : wtoip
Source Server Version : 50625
Source Host           : 192.168.30.25:3306
Source Database       : book_mgr

Target Server Type    : MYSQL
Target Server Version : 50625
File Encoding         : 65001

Date: 2016-09-06 10:58:05
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for book
-- ----------------------------
DROP TABLE IF EXISTS `book`;
CREATE TABLE `book` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '图书的id',
  `isbn10` varchar(255) DEFAULT NULL COMMENT '国际标准书号',
  `title` varchar(255) DEFAULT '' COMMENT '原始标题',
  `alt_title` varchar(255) DEFAULT NULL COMMENT '修改后的标题',
  `subtitle` varchar(255) DEFAULT NULL COMMENT '副标题',
  `url` varchar(255) DEFAULT NULL COMMENT '豆瓣api url',
  `alt` varchar(255) DEFAULT NULL COMMENT '豆瓣读书的详情页',
  `image` varchar(255) DEFAULT NULL COMMENT '图书默认封面',
  `author` varchar(255) DEFAULT NULL COMMENT '作者',
  `translator` varchar(255) DEFAULT NULL COMMENT '翻译人',
  `publisher` varchar(255) DEFAULT NULL COMMENT '出版商',
  `pubdate` varchar(255) DEFAULT NULL COMMENT '出版日期',
  `binding` varchar(255) DEFAULT NULL COMMENT '书面材料',
  `price` varchar(30) DEFAULT NULL COMMENT '价格',
  `pages` varchar(255) DEFAULT NULL COMMENT '总页数',
  `author_intro` text COMMENT '作者的简介',
  `summary` text COMMENT '图书简介',
  `catalog` text COMMENT '按目录分类,序言',
  `isbn13` varchar(255) DEFAULT NULL,
  `images` text,
  `series` text,
  `book_state` int(11) unsigned DEFAULT '0' COMMENT '0 不推荐，1 推荐',
  `tags` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=140 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of book
-- ----------------------------
INSERT INTO `book` VALUES ('110', '711541629X', 'Python网络数据采集', '', '', 'https://api.douban.com/v2/book/26740503', 'https://book.douban.com/subject/26740503/', 'https://img1.doubanio.com/mpic/s28487599.jpg', '[美] Ryan Mitchell', '陶俊杰,陈小莉', '人民邮电出版社', '2016-3', '平装', '59.00元', '216', 'Ryan Mitchell\n数据科学家、软件工程师，目前在波士顿LinkeDrive公司负责开发公司的API和数据分析工具。此前，曾在Abine公司构建网络爬虫和网络机器人。她经常做网络数据采集项目的咨询工作，主要面向金融和零售业。另著有Instant Web Scraping with Java。', '本书采用简洁强大的Python语言，介绍了网络数据采集，并为采集新式网络中的各种数据类型提供了全面的指导。第一部分重点介绍网络数据采集的基本原理：如何用Python从网络服务器请求信息，如何对服务器的响应进行基本处理，以及如何以自动化手段与网站进行交互。第二部分介绍如何用网络爬虫测试网站，自动化处理，以及如何通过更多的方式接入网络。', '译者序　　ix\n前言　　xi\n第一部分　创建爬虫\n第1章　初见网络爬虫　　2\n1.1　网络连接　　2\n1.2　BeautifulSoup简介　　4\n1.2.1　安装BeautifulSoup　　5\n1.2.2　运行BeautifulSoup　　7\n1.2.3　可靠的网络连接　　8\n第2章　复杂HTML解析　　11\n2.1　不是一直都要用锤子　　11\n2.2　再端一碗BeautifulSoup　　12\n2.2.1　BeautifulSoup的find()和findAll()　　13\n2.2.2　其他BeautifulSoup对象　　15\n2.2.3　导航树　　16\n2.3　正则表达式　　19\n2.4　正则表达式和BeautifulSoup　　23\n2.5　获取属性　　24\n2.6　Lambda表达式　　24\n2.7　超越BeautifulSoup　　25\n第3章　开始采集　　26\n3.1　遍历单个域名　　26\n3.2　采集整个网站　　30\n3.3　通过互联网采集　　34\n3.4　用Scrapy采集　　38\n第4章　使用API　　42\n4.1　API概述　　43\n4.2　API通用规则　　43\n4.2.1　方法　　44\n4.2.2　验证　　44\n4.3　服务器响应　　45\n4.4　Echo Nest　　46\n4.5　Twitter API　　48\n4.5.1　开始　　48\n4.5.2　几个示例　　50\n4.6　Google API　　52\n4.6.1　开始　　52\n4.6.2　几个示例　　53\n4.7　解析JSON数据　　55\n4.8　回到主题　　56\n4.9　再说一点API　　60\n第5章　存储数据　　61\n5.1　媒体文件　　61\n5.2　把数据存储到CSV　　64\n5.3　MySQL　　65\n5.3.1　安装MySQL　　66\n5.3.2　基本命令　　68\n5.3.3　与Python整合　　71\n5.3.4　数据库技术与最佳实践　　74\n5.3.5　MySQL里的“六度空间游戏”　　75\n5.4　Email　　77\n第6章　读取文档　　80\n6.1　文档编码　　80\n6.2　纯文本　　81\n6.3　CSV　　85\n6.4　PDF　　87\n6.5　微软Word和.docx　　88\n第二部分　高级数据采集\n第7章　数据清洗　　94\n7.1　编写代码清洗数据　　94\n7.2　数据存储后再清洗　　98\n第8章　自然语言处理　　103\n8.1　概括数据　　104\n8.2　马尔可夫模型　　106\n8.3　自然语言工具包　　112\n8.3.1　安装与设置　　112\n8.3.2　用NLTK做统计分析　　113\n8.3.3　用NLTK做词性分析　　115\n8.4　其他资源　　119\n第9章　穿越网页表单与登录窗口进行采集　　120\n9.1　Python Requests库　　120\n9.2　提交一个基本表单　　121\n9.3　单选按钮、复选框和其他输入　　123\n9.4　提交文件和图像　　124\n9.5　处理登录和cookie　　125\n9.6　其他表单问题　　127\n第10章　采集JavaScript　　128\n10.1　JavaScript简介　　128\n10.2　Ajax和动态HTML　　131\n10.3　处理重定向　　137\n第11章　图像识别与文字处理　　139\n11.1　OCR库概述　　140\n11.1.1　Pillow　　140\n11.1.2　Tesseract　　140\n11.1.3　NumPy　　141\n11.2　处理格式规范的文字　　142\n11.3　读取验证码与训练Tesseract　　146\n11.4　获取验证码提交答案　　151\n第12章　避开采集陷阱　　154\n12.1　道德规范　　154\n12.2　让网络机器人看起来像人类用户　　155\n12.2.1　修改请求头　　155\n12.2.2　处理cookie　　157\n12.2.3　时间就是一切　　159\n12.3　常见表单安全措施　　159\n12.3.1　隐含输入字段值　　159\n12.3.2　避免蜜罐　　160\n12.4　问题检查表　　162\n第13章　用爬虫测试网站　　164\n13.1　测试简介　　164\n13.2　Python单元测试　　165\n13.3　Selenium单元测试　　168\n13.4　Python单元测试与Selenium单元测试的选择　　172\n第14章　远程采集　　174\n14.1　为什么要用远程服务器　　174\n14.1.1　避免IP地址被封杀　　174\n14.1.2　移植性与扩展性　　175\n14.2　Tor代理服务器　　176\n14.3　远程主机　　177\n14.3.1　从网站主机运行　　178\n14.3.2　从云主机运行　　178\n14.4　其他资源　　179\n14.5　勇往直前　　180\n附录A　Python简介　　181\n附录B　互联网简介　　184\n附录C　网络数据采集的法律与道德约束　　188\n作者简介　　200\n封面介绍　　200', '9787115416292', '{\"small\":\"https://img1.doubanio.com/spic/s28487599.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s28487599.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s28487599.jpg\"}', 'undefined', '1', '[{\"count\":71,\"name\":\"python\",\"title\":\"python\"},{\"count\":67,\"name\":\"爬虫\",\"title\":\"爬虫\"},{\"count\":36,\"name\":\"数据挖掘\",\"title\":\"数据挖掘\"},{\"count\":27,\"name\":\"Python\",\"title\":\"Python\"},{\"count\":16,\"name\":\"计算机科学\",\"title\":\"计算机科学\"},{\"count\":12,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":12,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":8,\"name\":\"Programming\",\"title\":\"Programming\"}]');
INSERT INTO `book` VALUES ('112', '711137004X', 'Java并发编程实战', 'Java Concurrency in Practice', '', 'https://api.douban.com/v2/book/10484692', 'https://book.douban.com/subject/10484692/', 'https://img3.doubanio.com/mpic/s7663093.jpg', 'Brian Goetz,Tim Peierls,Joshua Bloch,Joseph Bowbeer,David Holmes,Doug Lea', '童云兰', '机械工业出版社华章公司', '2012-2', '平装', '69.00元', '293', '本书作者都是Java Community Process JSR 166专家组（并发工具）的主要成员，并在其他很多JCP专家组里任职。Brian Goetz有20多年的软件咨询行业经验，并著有至少75篇关于Java开发的文章。Tim Peierls是“现代多处理器”的典范，他在BoxPop.biz、唱片艺术和戏剧表演方面也颇有研究。Joseph Bowbeer是一个Java ME专家，他对并发编程的兴趣始于Apollo计算机时代。David Holmes是《The Java Programming Language》一书的合著者，任职于Sun公司。Joshua Bloch是Google公司的首席Java架构师，《Effective Java》一书的作者，并参与著作了《Java Puzzlers》。Doug Lea是《Concurrent Programming》一书的作者，纽约州立大学 Oswego分校的计算机科学教授。', '本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。\n本书适合Java程序开发人员阅读。', '对本书的赞誉\n译者序\n前　言\n第1章　简介1\n1.1　并发简史1\n1.2　线程的优势2\n1.2.1　发挥多处理器的强大能力2\n1.2.2　建模的简单性3\n1.2.3　异步事件的简化处理3\n1.2.4　响应更灵敏的用户界面4\n1.3　线程带来的风险4\n1.3.1　安全性问题5\n1.3.2　活跃性问题7\n1.3.3　性能问题7\n1.4　线程无处不在7\n第一部分　基础知识\n第2章　线程安全性11\n2.1　什么是线程安全性13\n2.2　原子性14\n2.2.1　竞态条件15\n2.2.2　示例：延迟初始化中的竞态条件16\n2.2.3　复合操作17\n2.3　加锁机制18\n2.3.1　内置锁20\n2.3.2　重入21\n2.4　用锁来保护状态22\n2.5　活跃性与性能23\n第3章　对象的共享27\n3.1　可见性27\n3.1.1　失效数据28\n3.1.2　非原子的64位操作29\n3.1.3　加锁与可见性30\n3.1.4　Volatile变量 30\n3.2　发布与逸出32\n3.3　线程封闭35\n3.3.1　Ad-hoc线程封闭35\n3.3.2　栈封闭36\n3.3.3　ThreadLocal类37\n3.4　不变性38\n3.4.1　Final域39\n3.4.2　示例：使用Volatile类型来发布不可变对象40\n3.5　安全发布41\n3.5.1　不正确的发布：正确的对象被破坏42\n3.5.2 　不可变对象与初始化安全性42\n3.5.3　安全发布的常用模式43\n3.5.4　事实不可变对象44\n3.5.5　可变对象44\n3.5.6　安全地共享对象44\n第4章　对象的组合46\n4.1　设计线程安全的类46\n4.1.1　收集同步需求47\n4.1.2　依赖状态的操作48\n4.1.3　状态的所有权48\n4.2　实例封闭49\n4.2.1　Java监视器模式51\n4.2.2　示例：车辆追踪51\n4.3　线程安全性的委托53\n4.3.1　示例：基于委托的车辆追踪器54\n4.3.2　独立的状态变量55\n4.3.3　当委托失效时56\n4.3.4　发布底层的状态变量57\n4.3.5　示例：发布状态的车辆追踪器58\n4.4　在现有的线程安全类中添加功能59\n4.4.1　客户端加锁机制60\n4.4.2　组合62\n4.5　将同步策略文档化62\n第5章　基础构建模块66\n5.1　同步容器类66\n5.1.1　同步容器类的问题66\n5.1.2　迭代器与Concurrent-ModificationException68\n5.1.3　隐藏迭代器69\n5.2　并发容器70\n5.2.1　ConcurrentHashMap71\n5.2.2　额外的原子Map操作72\n5.2.3　CopyOnWriteArrayList72\n5.3　阻塞队列和生产者-消费者模式73\n5.3.1　示例：桌面搜索75\n5.3.2　串行线程封闭76\n5.3.3　双端队列与工作密取77\n5.4　阻塞方法与中断方法77\n5.5　同步工具类78\n5.5.1　闭锁79\n5.5.2　FutureTask80\n5.5.3　信号量82\n5.5.4　栅栏83\n5.6　构建高效且可伸缩的结果缓存85\n第二部分　结构化并发应用程序\n第6章　任务执行93\n6.1　在线程中执行任务93\n6.1.1　串行地执行任务94\n6.1.2　显式地为任务创建线程94\n6.1.3　无限制创建线程的不足95\n6.2　Executor框架96\n6.2.1　示例：基于Executor的Web服务器97\n6.2.2　执行策略98\n6.2.3　线程池98\n6.2.4　Executor的生命周期99\n6.2.5　延迟任务与周期任务101\n6.3　找出可利用的并行性102\n6.3.1　示例：串行的页面渲染器102\n6.3.2　携带结果的任务Callable与Future103\n6.3.3　示例：使用Future实现页面渲染器104\n6.3.4　在异构任务并行化中存在的局限106\n6.3.5　CompletionService:Executor与BlockingQueue106\n6.3.6　示例：使用CompletionService实现页面渲染器107\n6.3.7　为任务设置时限108\n6.3.8　示例：旅行预定门户网站109\n第7章　取消与关闭111\n7.1　任务取消111\n7.1.1　中断113\n7.1.2　中断策略116\n7.1.3　响应中断117\n7.1.4　示例：计时运行118\n7.1.5　通过Future来实现取消120\n7.1.6　处理不可中断的阻塞121\n7.1.7　采用newTaskFor来封装非标准的取消122\n7.2　停止基于线程的服务124\n7.2.1　示例：日志服务124\n7.2.2　关闭ExecutorService127\n7.2.3　“毒丸”对象128\n7.2.4　示例：只执行一次的服务129\n7.2.5　shutdownNow的局限性130\n7.3　处理非正常的线程终止132\n7.4　JVM关闭135\n7.4.1　关闭钩子135\n7.4.2　守护线程136\n7.4.3　终结器136\n第8章　线程池的使用138\n8.1　在任务与执行策略之间的隐性耦合138\n8.1.1　线程饥饿死锁139\n8.1.2　运行时间较长的任务140\n8.2　设置线程池的大小140\n8.3　配置ThreadPoolExecutor141\n8.3.1　线程的创建与销毁142\n8.3.2　管理队列任务142\n8.3.3　饱和策略144\n8.3.4　线程工厂146\n8.3.5　在调用构造函数后再定制ThreadPoolExecutor147\n8.4　扩展 ThreadPoolExecutor148\n8.5　递归算法的并行化149\n第9章　图形用户界面应用程序156\n9.1　为什么GUI是单线程的156\n9.1.1　串行事件处理157\n9.1.2　Swing中的线程封闭机制158\n9.2　短时间的GUI任务160\n9.3　长时间的GUI任务161\n9.3.1　取消162\n9.3.2　进度标识和完成标识163\n9.3.3　SwingWorker165\n9.4　共享数据模型165\n9.4.1　线程安全的数据模型166\n9.4.2　分解数据模型166\n9.5　其他形式的单线程子系统167\n第三部分　活跃性、性能与测试\n第10章　避免活跃性危险169\n10.1　死锁169\n10.1.1　锁顺序死锁170\n10.1.2　动态的锁顺序死锁171\n10.1.3　在协作对象之间发生的死锁174\n10.1.4　开放调用175\n10.1.5　资源死锁177\n10.2　死锁的避免与诊断178\n10.2.1　支持定时的锁178\n10.2.2　通过线程转储信息来分析死锁178\n10.3　其他活跃性危险180\n10.3.1　饥饿180\n10.3.2　糟糕的响应性181\n10.3.3　活锁181\n第11章　性能与可伸缩性183\n11.1　对性能的思考183\n11.1.1　性能与可伸缩性184\n11.1.2　评估各种性能权衡因素185\n11.2　Amdahl定律186\n11.2.1　示例：在各种框架中隐藏的串行部分188\n11.2.2　Amdahl定律的应用189\n11.3　线程引入的开销189\n11.3.1　上下文切换190\n11.3.2　内存同步190\n11.3.3　阻塞192\n11.4　减少锁的竞争192\n11.4.1　缩小锁的范围（“快进快出”）193\n11.4.2　减小锁的粒度195\n11.4.3　锁分段196\n11.4.4　避免热点域197\n11.4.5　一些替代独占锁的方法198\n11.4.6　监测CPU的利用率199\n11.4.7　向对象池说“不”200\n11.5　示例：比较Map的性能200\n11.6　减少上下文切换的开销201\n第12章　并发程序的测试204\n12.1　正确性测试205\n12.1.1　基本的单元测试206\n12.1.2　对阻塞操作的测试207\n12.1.3　安全性测试208\n12.1.4　资源管理的测试212\n12.1.5　使用回调213\n12.1.6　产生更多的交替操作214\n12.2　性能测试215\n12.2.1　在PutTakeTest中增加计时功能215\n12.2.2　多种算法的比较217\n12.2.3　响应性衡量218\n12.3　避免性能测试的陷阱220\n12.3.1　垃圾回收220\n12.3.2　动态编译220\n12.3.3　对代码路径的不真实采样222\n12.3.4　不真实的竞争程度222\n12.3.5　无用代码的消除223\n12.4　其他的测试方法224\n12.4.1　代码审查224\n12.4.2　静态分析工具224\n12.4.3　面向方面的测试技术226\n12.4.4　分析与监测工具226\n第四部分　高级主题\n第13章　显式锁227\n13.1　Lock与 ReentrantLock227\n13.1.1　轮询锁与定时锁228\n13.1.2　可中断的锁获取操作230\n13.1.3　非块结构的加锁231\n13.2　性能考虑因素231\n13.3　公平性232\n13.4　在synchronized和ReentrantLock之间进行选择234\n13.5　读-写锁235\n第14章　构建自定义的同步工具238\n14.1　状态依赖性的管理238\n14.1.1　示例：将前提条件的失败传递给调用者240\n14.1.2　示例：通过轮询与休眠来实现简单的阻塞241\n14.1.3　条件队列243\n14.2　使用条件队列244\n14.2.1　条件谓词244\n14.2.2　过早唤醒245\n14.2.3　丢失的信号246\n14.2.4　通知247\n14.2.5　示例：阀门类248\n14.2.6　子类的安全问题249\n14.2.7　封装条件队列250\n14.2.8　入口协议与出口协议250\n14.3　显式的Condition对象251\n14.4　Synchronizer剖析253\n14.5　AbstractQueuedSynchronizer254\n14.6　java.util.concurrent同步器类中的 AQS257\n14.6.1　ReentrantLock257\n14.6.2　Semaphore与CountDownLatch258\n14.6.3　FutureTask259\n14.6.4　ReentrantReadWriteLock259\n第15章　原子变量与非阻塞同步机制261\n15.1　锁的劣势261\n15.2　硬件对并发的支持262\n15.2.1　比较并交换263\n15.2.2　非阻塞的计数器264\n15.2.3　JVM对CAS的支持265\n15.3　原子变量类265\n15.3.1　原子变量是一种“更好的volatile”266\n15.3.2　性能比较：锁与原子变量267\n15.4　非阻塞算法270\n15.4.1　非阻塞的栈270\n15.4.2　非阻塞的链表272\n15.4.3　原子的域更新器274\n15.4.4　ABA问题275\n第16章　Java内存模型277\n16.1　什么是内存模型，为什么需要它277\n16.1.1　平台的内存模型278\n16.1.2　重排序278\n16.1.3　Java内存模型简介280\n16.1.4　借助同步281\n16.2　发布283\n16.2.1　不安全的发布283\n16.2.2　安全的发布284\n16.2.3　安全初始化模式284\n16.2.4　双重检查加锁286\n16.3　初始化过程中的安全性287\n附录A　并发性标注289\n参考文献291', '9787111370048', '{\"small\":\"https://img3.doubanio.com/spic/s7663093.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s7663093.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s7663093.jpg\"}', 'undefined', '0', '[{\"count\":725,\"name\":\"Java\",\"title\":\"Java\"},{\"count\":586,\"name\":\"并发\",\"title\":\"并发\"},{\"count\":419,\"name\":\"多线程\",\"title\":\"多线程\"},{\"count\":166,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":117,\"name\":\"java\",\"title\":\"java\"},{\"count\":101,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":57,\"name\":\"线程\",\"title\":\"线程\"},{\"count\":48,\"name\":\"软件开发\",\"title\":\"软件开发\"}]');
INSERT INTO `book` VALUES ('114', '711123183X', '数据结构与算法分析', '', 'Java语言描述', 'https://api.douban.com/v2/book/3351237', 'https://book.douban.com/subject/3351237/', 'https://img3.doubanio.com/mpic/s28318872.jpg', '韦斯 (Mark Allen Weiss)', '', '机械工业出版社', '2009-1-1', '平装', '55.00元', '400', 'MarkAllen Weiss拥有普林斯顿大学计算机科学博士学位，现在是佛罗里达国际大学计算机学院教授。他是著名的计算机教育专家，在数据结构与算法分析方面卓有建树，著有多部畅销书籍：《Data Structures and Problem Solving：LJsirlg、Java》、《Data Structures and Problem Solving：Using C++》、《数据结构与算法分析——C语言描述》等。他目前是AP(AdvancedPlacement)计算机学科委员会成员。', '本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。    随着计算机速度的不断增加和功能的日益强大，人们对有效编程和算法分析的要求也不断增长。本书把算法分析与最有效率的Java程序的开发有机地结合起来，深入分析每种算法，内容全面、缜密严格，并细致讲解精心构造程序的方法。', '译者序\n前言\n第1章 引论\n1.1 本书讨论的内容\n1.2 数学知识复习\n1.2.1 指数\n1.2.2 对数\n1.2.3 级数\n1.2.4 模运算\n1.2.5 证明的方法\n1.3 递归简论\n1.4 实现泛型特性构件pre-Java5\n1.4.1 使用Object表示泛型\n1.4.2 基本类型的包装\n1.4.3 使用接口类型表示泛型\n1.4.4 数组类型的兼容性\n1.5 利用Java5泛性实现泛型特性成分\n1.5.1 简单的泛型类和接口\n1.5.2 自动装箱/拆箱\n1.5.3 带有限制的通配符\n1.5.4 泛型static方法\n1.5.5 类型限界\n1.5.6 类型擦除\n1.5.7 对于泛型的限制\n1.6 函数对象\n小结\n练习\n参考文献\n第2章 算法分析\n2.1 数学基础\n2.2 模型\n2.3 要分析的问题\n2.4 运行时间计算\n2.4.1 一个简单的例子\n2.4.2 一般法则\n2.4.3 最大子序列和问题的求解\n2.4.4 运行时间中的对数\n2.4.5 检验你的分析\n2.4.6 分析结果的准确性\n小结\n练习\n参考文献\n第3章 表、栈和队列\n3.1 抽象数据类型\n3.2 表ADT\n3.2.1 表的简单数组实现\n3.2.2 简单链表\n3.3 Java Collections API中的表\n3.3.1 Collection接口\n3.3.2 Iterator接口\n3.3.3 List接口、ArrayList类和LinkedList类\n3.3.4 例：remove方法对LinkedList类的使用\n3.3.5 关于ListIterator接口\n3.4 ArrayList类的实现\n3.4.1 基本类\n3.4.2 迭代器、Java嵌套类和内部类\n3.5 Linked List类的实现\n3.6 栈ADT\n3.6.1 栈模型\n3.6.2 栈的实现\n3.6.3 应用\n3.7 队列ADT\n3.7.1 队列模型\n3.7.2 队列的数组实现\n3.7.3 队列的应用\n小结\n练习\n第4章 树\n4.1 预备知识\n4.1.1 树的实现\n4.1.2 树的遍历及应用\n4.2 二叉树\n4.2.1 实现\n4.2.2 例子：表达式树\n4.3 查找树ADT——二叉查找树\n4.3.1 contains方法\n4.3.2 findMin方法和findMax方法\n4.3.3 insert方法\n4.3.4 remove方法\n4.3.5 平均情况分析\n4.4 AVL树\n4.4.1 单旋转\n4.4.2 双旋转\n4.5 伸展树\n4.5.1 一个简单的想法（不能直接使用）\n4.5.2 展开\n4.6 树的遍历\n4.7 B树\n4.8 标准库中的集合与映射\n4.8.1 关于Set接口\n4.8.2 关于Map接口\n4.8.3 TreeSet类和TreeMap类的实现\n4.8.4 使用多个映射的例\n小结\n练习\n参考文献\n第5章 散列\n5.1 一般想法\n5.2 散列函数\n5.3 分离链接法\n5.4 不用链表的散列表\n5.4.1 线性探测法\n5.4.2 平方探测法\n5.4.3 双散列\n5.5 再散列\n5.6 标准库中的散列表\n5.7 可扩散列\n小结\n练习\n参考文献\n第6章 优先队列（堆）\n6.1 模型\n6.2 一些简单的实现\n6.3 二叉堆\n6.3.1 结构性质\n6.3.2 堆序性质\n6.3.3 基本的堆操作\n6.3.4 其他的堆操作\n6.4 优先队列的应用\n6.4.1 选择问题\n6.4.2 事件模拟\n6.5 d-堆\n6.6 左式堆\n6.6.1 左式堆性质\n6.6.2 左式堆操作\n6.7 斜堆\n6.8 二项队列\n6.8.1 二项队列结构\n6.8.2 二项队列操作\n6.8.3 二项队列的实现\n6.9 标准库中的优先队列\n小结\n练习\n参考文献\n第7章 排序\n7.1 预备知识\n7.2 插入排序\n7.2.1 算法\n7.2.2 插入排序的分析\n7.3 一些简单排序算法的下界\n7.4 希尔排序\n7.5 堆排序\n7.6 归并排序\n7.7 快速排序\n7.7.1 选取枢纽元\n7.7.2 分割策略\n7.7.3 小数组\n7.7.4 实际的快速排序例程\n7.7.5 快速排序的分析\n7.7.6 选择问题的线性期望时间算法\n7.8 排序算法的一般下界\n7.9 桶式排序\n7.10 外部排序\n7.10.1 为什么需要一些新的算法\n7.10.2 外部排序模型\n7.10.3 简单算法\n7.10.4 多路合并\n7.10.5 多相合并\n7.10.6 替换选择\n小结\n练习题\n参考文献\n第8章 不相交集类\n8.1 等价关系\n8.2 动态等价性问题\n8.3 基本数据结构\n8.4 灵巧求并算法\n8.5 路径压缩\n8.6 路径压缩和按秩求并的最坏情形\n8.7 一个应用\n小结\n练习题\n参考文献\n第9章 图论算法\n9.1 若干定义\n9.2 拓扑排序\n9.3 最短路径算法\n9.3.1 无权最短路径\n9.3.2 Dijkstra算法\n9.3.3 具有负边值的图\n9.3.4 无圈图\n9.3.5 所有点对最短路径\n9.3.6 最短路径的例子\n9.4 网络流问题\n9.5 最小生成树\n9.5.1 Prim算法\n9.5.2 Kruskal算法\n9.6 深度优先搜索的应用\n9.6.1 无向图\n9.6.2 双连通性\n9.6.3 欧拉回路\n9.6.4 有向图\n9.6.5 查找强分支\n9.7 NP完全性介绍\n9.7.1 难与易\n9.7.2 NP类\n9.7.3 NP完全问题\n小结\n练习\n参考文献\n第10章 算法设计技巧\n10.1 贪婪算法\n10.1.1 一个简单的调度问题\n10.1.2 哈夫曼编码\n10.1.3 近似装箱问题\n10.2 分治算法\n10.2.1 分治算法的运行时间\n10.2.2 最近点问题\n10.2.3 选择问题\n10.2.4 一些算术问题的理论改进\n10.3 动态规划\n10.3.1 用一个表代替递归\n10.3.2 矩阵乘法的顺序安排\n10.3.3 最优二叉查找树\n10.3.4 所有点对最短路径\n10.4 随机化算法\n10.4.1 随机数发生器\n10.4.2 跳跃表\n10.4.3 素性测试\n10.5 回溯算法\n10.5.1 收费公路重建问题\n10.5.2 博弈\n小结\n练习\n参考文献\n第11章 摊还分析\n11.1 一个无关的智力问题\n11.2 二项队列\n11.3 斜堆\n11.4 斐波那契堆\n11.4.1 切除左式堆中的节点\n11.4.2 二项队列的懒惰合并\n11.4.3 斐波那契堆操作\n11.4.4 时间界的证明\n11.5 伸展树\n小结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12.1 自顶向下伸展树\n12.2 红黑树\n12.2.1 自底向上的插入\n12.2.2 自顶向下红黑树\n12.2.3 自顶向下的删除\n12.3 确定性跳跃表\n12.4 AA树\n12.5 treap树\n12.6 k-d树\n12.7 配对堆\n小结\n练习\n参考文献\n索引', '9787111231837', '{\"small\":\"https://img3.doubanio.com/spic/s28318872.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s28318872.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s28318872.jpg\"}', '{\"id\":\"1163\",\"title\":\"计算机科学丛书\"}', '1', '[{\"count\":159,\"name\":\"数据结构\",\"title\":\"数据结构\"},{\"count\":117,\"name\":\"算法\",\"title\":\"算法\"},{\"count\":115,\"name\":\"Java\",\"title\":\"Java\"},{\"count\":55,\"name\":\"算法、数据结构\",\"title\":\"算法、数据结构\"},{\"count\":35,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":27,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":16,\"name\":\"程序设计\",\"title\":\"程序设计\"},{\"count\":16,\"name\":\"java\",\"title\":\"java\"}]');
INSERT INTO `book` VALUES ('115', '7115272417', 'Android应用性能优化', 'Pro Android Apps Performance Optimization', '', 'https://api.douban.com/v2/book/19976838', 'https://book.douban.com/subject/19976838/', 'https://img3.doubanio.com/mpic/s22718876.jpg', '[法] Hervé Guihot', '白龙', '人民邮电出版社', '2012-10', '平装', '49.00元', '226', '作者介绍：\nHervé Guihot 目前在联发科技公司（MTK, www.mediatek.com）担任软件工程经理。他有十多年的嵌入式系统开发工作经验，主要与数字电视技术相关。目前正在研究如何将Android引入基于ARM的数字家庭平台（电视，蓝光播放器）。', '内容简介：\n今天的Android应用开发者经常要想尽办法来提升程序性能。由于应用越来越复杂，这个问题也变得越来越棘手。本书主要介绍如何快速高效地优化应用，让应用变得稳定高效。你将学会利用Android SDK和NDK来混合或单独使用Java、C/C++来开发应用。书中还特别讲解了如下内容：\n•        一些OpenGL的优化技术以及RenderScript（Android的新特性）的基础知识；\n•        利用SDK来优化应用的Java代码的技巧；\n•        通过高效使用内存来提升性能的技巧；\n•        延长电池使用时间的技巧；\n•        使用多线程的时机及技巧；\n•        评测剖析代码的技巧。\n把本书的内容学以致用，你的编程技术就会得到关键性的提升，写出的应用就会更为健壮高效，从而广受用户好评，并最终获得成功。', '目 　 　录\n第1章 　Java代码优化　　1\n1.1 　Android如何执行代码　　1\n1.2 　优化斐波纳契数列　　4\n1.2.1 　从递归到迭代　　4\n1.2.2 　BigInteger　　6\n1.3 　缓存结果　　10\n1.4 　API等级　　12\n1.5 　数据结构　　14\n1.6 　响应能力　　17\n1.6.1 　推迟初始化　　19\n1.6.2 　StrictMode　　19\n1.7 　SQLite　　21\n1.7.1 　SQLite语句　　21\n1.7.2 　事务　　25\n1.7.3 　查询　　26\n1.8 　总结　　27\n第2章 　NDK入门　　28\n2.1 　NDK里有什么　　28\n2.2 　混合使用Java和C/C++代码　　31\n2.2.1 　声明本地方法　　31\n2.2.2 　实现JNI粘合层　　32\n2.2.3 　创建Makefile　　33\n2.2.4 　实现本地函数　　35\n2.2.5 　编译本地库　　36\n2.2.6 　加载本地库　　37\n2.3 　Application.mk　　37\n2.3.1 　为（几乎）所有设备优化　　39\n2.3.2 　支持所有设备　　40\n2.4 　Android.mk　　43\n2.5 　使用C/C++改进性能　　45\n2.6 　本地Acitivity　　52\n2.6.1 　构建缺失的库　　54\n2.6.2 　替代方案　　59\n2.7 　总结　　60\n第3章 　NDK进阶　　61\n3.1 　汇编　　61\n3.1.1 　最大公约数　　62\n3.1.2 　色彩转换　　66\n3.1.3 　并行计算平均值　　70\n3.1.4 　ARM指令　　74\n3.1.5 　ARM NEON　　79\n3.1.6 　CPU特性　　80\n3.2 　C扩展　　81\n3.2.1 　内置函数　　82\n3.2.2 　向量指令　　82\n3.3 　技巧　　86\n3.3.1 　内联函数　　87\n3.3.2 　循环展开　　87\n3.3.3 　内存预读取　　87\n3.3.4 　用LDM/STM替换LDR/STD　　89\n3.4 　总结　　89\n第4章 　高效使用内存　　90\n4.1 　说说内存　　90\n4.2 　数据类型　　91\n4.2.1 　值的比较　　93\n4.2.2 　其他算法　　95\n4.2.3 　数组排序　　96\n4.2.4 　定义自己的类　　97\n4.3 　访问内存　　98\n4.4 　排布数据　　100\n4.5 　垃圾收集　　104\n4.5.1 　内存泄漏　　105\n4.5.2 　引用　　106\n4.6 　API　　109\n4.7 　内存少的时候　　110\n4.8 　总结　　111\n第5章 　多线程和同步　　112\n5.1 　线程　　112\n5.2 　AsyncTask　　115\n5.3 　Handler和Looper　　118\n5.3.1 　Handler　　118\n5.3.2 　Looper　　120\n5.4 　数据类型　　120\n5.5 　并发　　124\n5.6 　多核　　125\n5.6.1 　为多核修改算法　　126\n5.6.2 　使用并发缓存　　129\n5.7 　Activity生命周期　　131\n5.7.1 　传递信息　　132\n5.7.2 　记住状态　　134\n5.8 　总结　　137\n第6章 　性能评测和剖析　　138\n6.1 　时间测量　　138\n6.1.1 　System.nanoTime()　　139\n6.1.2 　Debug.threadCpuTimeNanos()　　140\n6.2 　方法调用跟踪　　141\n6.2.1 　Debug.startMethodTracing()　　141\n6.2.2 　使用Traceview工具　　142\n6.2.3 　DDMS中的Traceview　　144\n6.2.4 　本地方法跟踪　　145\n6.3 　日志　　147\n6.4 　总结　　148\n第7章 　延长电池续航时间　　150\n7.1 　电池　　150\n7.2 　禁用广播接收器　　155\n7.3 　网络　　159\n7.3.1 　后台数据　　159\n7.3.2 　数据传输　　160\n7.4 　位置　　162\n7.4.1 　注销监听器　　163\n7.4.2 　更新频率　　164\n7.4.3 　多种位置服务　　164\n7.4.4 　筛选定位服务　　166\n7.4.5 　最后已知位置　　168\n7.5 　传感器　　169\n7.6 　图形　　170\n7.7 　提醒　　171\n7.8 　WakeLock　　173\n7.9 　总结　　175\n第8章 　图形　　176\n8.1 　布局优化　　176\n8.1.1 　相对布局　　178\n8.1.2 　合并布局　　181\n8.1.3 　重用布局　　183\n8.1.4 　ViewStub　　184\n8.2 　布局工具　　185\n8.2.1 　层级视图　　186\n8.2.2 　layoutopt　　186\n8.3 　OpenGL ES　　186\n8.3.1 　扩展　　187\n8.3.2 　纹理压缩　　189\n8.3.3 　Mipmap　　193\n8.3.4 　多APK　　194\n8.3.5 　着色　　195\n8.3.6 　场景复杂性　　195\n8.3.7 　消隐　　195\n8.3.8 　渲染模式　　195\n8.3.9 　功耗管理　　195\n8.4 　总结　　196\n第9章 　RenderScript　　197\n9.1 　概览　　197\n9.2 　Hello World　　199\n9.3 　Hello Rendering　　202\n9.3.1 　创建渲染脚本　　202\n9.3.2 　创建RenderScriptGL Context　　203\n9.3.3 　展开RSSurfaceView　　204\n9.3.4 　设置内容视图　　204\n9.4 　在脚本中添加变量　　205\n9.5 　HelloCompute　　208\n9.5.1 　Allocation　　209\n9.5.2 　rsForEach　　210\n9.5.3 　性能　　213\n9.6 　自带的RenderScript API　　214\n9.6.1 　rs_types.rsh　　215\n9.6.2 　rs_core.rsh　　217\n9.6.3 　rs_cl.rsh　　219\n9.6.4 　rs_math.rsh　　222\n9.6.5 　rs_graphics.rsh　　223\n9.6.6 　rs_time.rsh　　224\n9.6.7 　rs_atomic.rsh　　225\n9.7 　RenderScript与NDK对比　　225\n9.8 　总结　　226\n', '9787115272416', '{\"small\":\"https://img3.doubanio.com/spic/s22718876.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s22718876.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s22718876.jpg\"}', 'undefined', '1', '[{\"count\":129,\"name\":\"Android\",\"title\":\"Android\"},{\"count\":59,\"name\":\"性能\",\"title\":\"性能\"},{\"count\":22,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":13,\"name\":\"android\",\"title\":\"android\"},{\"count\":12,\"name\":\"软件开发\",\"title\":\"软件开发\"},{\"count\":12,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":8,\"name\":\"程序设计\",\"title\":\"程序设计\"},{\"count\":7,\"name\":\"软件工程\",\"title\":\"软件工程\"}]');
INSERT INTO `book` VALUES ('116', '7111262816', 'PHP和MySQL Web开发(原书第4版)', 'PHP and MySQL Web Development, Fourth Edition', 'PHP and MySQL Web Development, Fourth Edition', 'https://api.douban.com/v2/book/3549421', 'https://book.douban.com/subject/3549421/', 'https://img3.doubanio.com/mpic/s3773304.jpg', 'Luke Welling,Laura Thomson', '武欣', '机械工业出版社', '2009', '16开', '95.00元', '714', 'Laura Thomson是Mozilla公司的高级软件工程师。之前，她是OmniTI公司和Tangled Web Design公司的合伙人。此外，Laura曾经在RMIT大学和波士顿顾问集团工作过。她获得了应用科学（计算机科学）的学士学位和工程学（计算机系统工程）学士学位。在她的空闲时间，她非常喜欢骑马，讨论免费软件和开源软件以及睡觉。.\nLuke Welling是OmniTI公司的一位Web架构师，他经常在一些国际会议（例如，OSCON， ZendCon， MySQLUC，HPCon，OSDC以及LinuxTag）中就开源和Web开发的话题发表演讲。在加入OmniTI公司..', '本书将PHP开发与MySQL应用相结合，分别对PHP和MySQL做了深入浅出的分析，不仅介绍PHP和MySQL的一般概念，而且对PHP和MySQL的Web应用做了较全面的阐述，并包括几个经典且实用的例子。.\n本书是第4版，经过了全面的更新、重写和扩展，包括PHP 5.3最新改进的特性（例如，更好的错误和异常处理），MySQL的存储过程和存储引擎，Ajax技术与Web 2.0以及Web应用需要注意的安全问题。...', '读者反馈\n译者序\n前言\n作者简介\n第一篇 使用PHP\n第1章 PHP快速入门教程\n1.1 开始之前：了解PHP\n1.2 创建一个示例应用：Bob汽车零部件商店\n1.2.1 创建订单表单\n1.2.2 表单处理\n1.3 在HTML中嵌入PHP\n1.3.1 使用PHP标记\n1.3.2 PHP语句\n1.3.3 空格\n1.3.4 注释\n1.4 添加动态内容\n1.4.1 调用函数\n1.4.2 使用date()函数\n1.5 访问表单变量\n1.5.1 简短、中等以及长风格的表单变量\n1.5.2 字符串的连接\n1.5.3 变量和文本\n1.6 理解标识符\n1.7 检查变量类型\n1.7.1 PHP的数据类型\n1.7.2 类型强度\n1.7.3 类型转换\n1.7.4 可变变量\n1.8 声明和使用常量\n1.9 理解变量的作用域\n1.10 使用操作符\n1.10.1 算术操作符\n1.10.2 字符串操作符\n1.10.3 赋值操作符\n1.10.4 比较操作符\n1.10.5 逻辑操作符\n1.10.6 位操作符\n1.10.7 其他操作符\n1.11  计算表单总金额\n1.12  理解操作符的优先级和结合性：\n1.13 使用可变函数\n1.13.1 测试和设置变量类型\n1.13.2 测试变量状态\n1.13.3 变量的重解释\n1.14 根据条件进行决策\n1.14.1 if语句\n1.14.2 代码块\n1.14.3 else语句\n1.14.4 elseif语句\n1.14.5 switch语句\n1.14.6 比较不同的条件\n1.15 通过迭代实现重复动作\n1.15.1 while循环\n1.15.2 for和foreach循环\n1.15.3 do...while循环\n1.16 从控制结构或脚本中跳出\n1.17 使用可替换的控制结构语法\n1.18 使用declare\n1.19 下一章\n第2章 数据的存储与检索\n2.1 保存数据以便后期使用\n2.2 存储和检索Bob的订单\n2.3 文件处理\n2.4 打开文件\n2.4.1 选择文件模式\n2.4.2 使用fopen()打开文件\n2.4.3 通过FTP或HTTP打开文件\n2.4.4 解决打开文件时可能遇到的问题\n2.5 写文件\n2.5.1 fwrite()的参数\n2.5.2 文件格式\n2.6 关闭文件\n2.7 读文件\n2.7.1 以只读模式打开文件：fopen()\n2.7.2 知道何时读完文件：feof()\n2.7.3 每次读取一行数据：fgets()、fgetss()和fgetcsv()\n2.7.4 读取整个文件：readfile()、fpassthru()和file()\n2.7.5 读取一个字符：fgetc()\n2.7.6 读取任意长度：fread()\n2.8 使用其他有用的文件函数\n2.8.1 查看文件是否存在：file_exists()\n2.8.2 确定文件大小：filesize()\n2.8.3 删除一个文件：unlink()\n2.8.4 在文件中定位：rewind()、fseek()和ftell()\n2.9 文件锁定\n2.10 更好的方式：数据库管理系统\n2.10.1 使用普通文件的几个问题\n2.10.2  RDBMS是如何解决这些问题的\n2.11 进一步学习\n2.12 下一章\n第3章 使用数组\n3.1 什么是数组\n3.2 数字索引数组\n3.2.1 数字索引数组的初始化\n3.2.2 访问数组的内容\n3.2.3 使用循环访问数组\n3.3 使用不同索引的数组\n3.3.1 初始化相关数组\n3.3.2 访问数组元素\n3.3.3 使用循环语句\n3.4 数组操作符\n3.5 多维数组\n3.6 数组排序\n3.6.1 使用sort()函数\n3.6.2 使用asort()函数和ksort()函数对相关数组排序\n3.6.3 反向排序\n3.7 多维数组的排序\n3.7.1 用户定义排序\n3.7.2 反向用户排序\n3.8 对数组进行重新排序\n3.8.1 使用shuffle()函数\n3.8.2 使用array_reverse()函数\n3.9 从文件载入数组\n3.10 执行其他的数组操作\n3.10.1 在数组中浏览：each()、current()、reset()、end()、next()、pos()和prev()\n3.10.2 对数组的每一个元素应用任何函数：array_walk()\n3.10.3 统计数组元素个数：count()、sizeof()和array_count_values()\n3.10.4 将数组转换成标量变量：extract()\n3.11 进一步学习\n3.12 下一章\n第4章 字符串操作与正则表达式\n4.1 创建一个示例应用程序：智能表单邮件\n4.2 字符串的格式化\n4.2.1 字符串的整理：chop()、ltrim()和trim()\n4.2.2 格式化字符串以便显示\n4.2.3 格式化字符串以便存储：addslashes()和stripslashes()\n4.3 用字符串函数连接和分割字符串\n4.3.1 使用函数explode()、implode()和join()\n4.3.2 使用strtok()函数\n4.3.3 使用substr()函数\n4.4 字符串的比较\n4.4.1 字符串的排序：strcmp()、strcasecmp()和strnatcmp()\n4.4.2 使用strlen()函数测试字符串的长度\n4.5 使用字符串函数匹配和替换子字符串\n4.5.1 在字符串中查找字符串：strstr()、strchr()、strrchr()和stristr()\n4.5.2 查找子字符串的位置：strpos()、strrpos()\n4.5.3 替换子字符串：str_replace()、substr_replace()\n4.6 正则表达式的介绍\n4.6.1 基础知识\n4.6.2 字符集和类\n4.6.3 重复\n4.6.4 子表达式\n4.6.5 子表达式计数\n4.6.6 定位到字符串的开始或末尾\n4.6.7 分支\n4.6.8 匹配特殊字符\n4.6.9 特殊字符一览\n4.6.10 在智能表单中应用\n4.7 用正则表达式查找子字符串\n4.8 使用正则表达式分割字符串\n4.9 比较字符串函数和正则表达式函数\n4.10 进一步学习\n4.11 下一章\n第5章 代码重用与函数编写\n5.1 代码重用的好处\n5.1.1 成本\n5.1.2 可靠性\n5.1.3 一致性\n5.2 使用require()和include()函数\n5.2.1 文件扩展名和require()语句\n5.2.2 使用require()制作Web站点的模版\n5.2.3 使用auto_prepend_file和auto_append_file\n5.3 在PHP中使用函数\n5.3.1 调用函数\n5.3.2 调用未定义的函数\n5.3.3 理解字母大小写和函数名称\n5.4 理解为什么要定义自己的函数\n5.5 了解基本的函数结构\n5.5.1 函数命名\n5.6 使用参数\n5.7 理解作用域\n5.8 参数的引用传递和值传递\n5.9  使用Return关键字\n5.9.1 从函数返回一个值\n5.10  实现递归\n5.10.1 名称空间\n5.11 进一步学习\n5.12 下一章\n第6章 面向对象的PHP\n6.1 理解面向对象的概念\n6.1.1 类和对象\n6.1.2 多态性\n6.1.3 继承\n6.2 在PHP中创建类、属性和操作\n6.2.1 类的结构\n6.2.2 构造函数\n6.2.3 析构函数\n6.3 类的实例化\n6.4 使用类的属性\n6.5 使用private和public关键字控制访问\n6.6 类操作的调用\n6.7 在PHP中实现继承\n6.7.1 通过继承使用private和protected访问修饰符控制可见性\n6.7.2 重载\n6.7.3 使用final关键字禁止继承和重载\n6.7.4 理解多重继承\n6.7.5 实现接口\n6.8 类的设计\n6.9 编写类代码\n6.10 理解PHP面向对象新的高级功能\n6.10.1 使用Per-Class常量\n6.10.2 实现静态方法\n6.10.3 检查类的类型和类型提示\n6.10.4 克隆对象\n6.10.5 使用抽象类\n6.10.6 使用__call()重载方法\n6.10.7 使用__autoload()方法\n6.10.8 实现迭代器和迭代\n6.10.9 将类转换成字符串\n6.10.10 使用Reflection（反射）API\n6.11 下一章\n第7章  错误和 异常处理\n7.1 异常处理的概念\n7.2 Exception类\n7.3 用户自定义异常\n7.4 Bob的汽车零部件商店应用程序的异常\n7.5 异常和PHP的其他错误处理机制\n7.6 进一步学习\n7.7 下一章\n第二篇 使用MySQL\n第8章 设计Web数据库\n8.1 关系数据库的概念\n8.1.1 表格\n8.1.2 列\n8.1.3 行\n8.1.4 值\n8.1.5 键\n8.1.6 模式\n8.1.7 关系\n8.2 如何设计Web数据库\n8.2.1 考虑要建模的实际对象\n8.2.2 避免保存冗余数据\n8.2.3 使用原子列值\n8.2.4 选择有意义的键\n8.2.5 考虑需要询问数据库的问题\n8.2.6 避免多个空属性的设计\n8.2.7 表格类型的总结\n8.3 Web数据库架构\n8.4 进一步学习\n8.5 下一章\n第9章 创建Web数据库\n9.1 使用MySQL监视程序\n9.2 登录到MySQL\n9.3 创建数据库和用户\n9.4 设置用户与权限\n9.5 MySQL权限系统的介绍\n9.5.1 最少权限原则\n9.5.2 创建用户：GRANT命令\n9.5.3 权限的类型和级别\n9.5.4 REVOKE命令\n9.5.5 使用GRANT和REVOKE的例子\n9.6 创建一个Web用户\n9.7 使用正确的数据库\n9.8 创建数据库表\n9.8.1 理解其他关键字的意思\n9.8.2 理解列的类型\n9.8.3 用SHOW和DESCRIBE来查看数据库\n9.8.4 创建索引\n9.9 理解MySQL的标识符\n9.10 选择列数据类型\n9.10.1 数字类型\n9.10.2 日期和时间类型\n9.10.3 字符串类型\n9.11 进一步学习\n9.12 下一章\n第10章 使用MySQL数据库\n10.1 SQL是什么\n10.2 在数据库中插入数据\n10.3 从数据库中获取数据\n10.3.1 获取满足特定条件的数据\n10.3.2 从多个表中获取数据\n10.3.3 以特定的顺序获取数据\n10.3.4 分组与合计数据\n10.3.5 选择要返回的行\n10.3.6 使用子查询\n10.4 更新数据库记录\n10.5 创建后修改表\n10.6 删除数据库中的记录\n10.7 表的删除\n10.8 删除整个数据库\n10.9 进一步学习\n10.10 下一章\n第11章 使用PHP从Web访问MySQL数据库\n11.1 Web数据库架构的工作原理\n11.2 从Web查询数据库的基本步骤\n11.2.1 检查与过滤用户输入数据\n11.2.2 建立一个连接\n11.2.3  选择使用的数据库\n11.2.4 查询数据库\n11.2.5 检索查询结果\n11.2.6 从数据库断开连接\n11.3 将新信息放入数据库\n11.4 使用Prepared语句\n11.5 使用PHP与数据库交互的其他接口\n11.5.1 使用常规的数据库接口：PEAR MDB2\n11.6 进一步学习\n11.7 下一章\n第12章 MySQL高级管理\n12.1 深入理解权限系统\n12.1.1 user表\n12.1.2 db表和host表\n12.1.3 tables_priv表，columns_priv表和procs_priv表\n12.1.4 访问控制：MySQL如何使用Grant表\n12.1.5 更新权限：修改什么时候生效\n12.2 提高MySQL数据库的安全性\n12.2.1 从操作系统角度来保护MySQL\n12.2.2 密码\n12.2.3 用户权限\n12.2.4 Web问题\n12.3 获取更多关于数据库的信息\n12.3.1 使用SHOW获取信息\n12.3.2 使用DESCRIBE获取关于列的信息\n12.3.3 用EXPLAIN理解查询操作的工作过程\n12.4 数据库的优化\n12.4.1 设计优化\n12.4.2 权限\n12.4.3 表的优化\n12.4.4 使用索引\n12.4.5 使用默认值\n12.4.6 其他技巧\n12.5 备份MySQL数据库\n12.6 恢复MySQL数据库\n12.7 实现复制\n12.7.1 设置主服务器\n12.7.2 执行初始的数据传输\n12.7.3 设置一个/多个从服务器\n12.8 进一步学习\n12.9 下一章\n第13章 MySQL高级编程\n13.1 LOAD DATA INFILE语句\n13.2 存储引擎\n13.3 事务\n13.3.1 理解事务的定义\n13.3.2 通过InnoDB使用事务\n13.4 外键\n13.5 存储过程\n13.5.1 基本示例\n13.5.2 局部变量\n13.5.3 游标和控制结构\n13.6 进一步学习\n13.7 下一章\n第三篇 电子商务与安全性\n第14章 运营一个电子商务网站\n14.1 我们要实现什么目标\n14.2 考虑电子商务网站的类型\n14.2.1 使用在线说明书公布信息\n14.2.2 接收产品或服务的订单\n14.2.3 提供服务和数字产品\n14.2.4 为产品或服务增值\n14.2.5 减少成本\n14.3 理解风险和威胁\n14.3.1 网络黑客\n14.3.2 不能招揽足够的生意\n14.3.3 计算机硬件故障\n14.3.4 电力、通信、网络或运输故障\n14.3.5 广泛的竞争\n14.3.6 软件错误\n14.3.7 不断变化的政府政策和税收\n14.3.8 系统容量限制\n14.4 选择一个策略\n14.5 下一章\n第15章 电子商务的安全问题\n15.1 信息的重要程度\n15.2 安全威胁\n15.2.1 机密数据的泄露\n15.2.2 数据丢失和数据破坏\n15.2.3 数据修改\n15.2.4 拒绝服务\n15.2.5 软件错误\n15.2.6 否认\n15.3 易用性，性能、成本和安全性\n15.4 建立一个安全政策\n15.5 身份验证原则\n15.6 加密技术基础\n15.6.1 私有密钥加密\n15.6.2  公有密钥加密\n15.6.3 数字签名\n15.7 数字证书\n15.8 安全的Web服务器\n15.9 审计与日志记录\n15.10 防火墙\n15.11 备份数据\n15.11.1 备份常规文件\n15.11.2 备份与恢复MySQL数据库\n15.12 自然环境安全\n15.13 下一章\n第16章  Web应用的安全\n16.1处理安全性问题的策略\n16.1.1 以正确心态为开始\n16.1.2 安全性和可用性之间的平衡\n16.1.3 安全监视\n16.1.4 基本方法\n16.2 识别所面临的威胁\n16.2.1 访问或修改敏感数据\n16.2.2 数据丢失或破坏\n16.2.3 拒绝服务\n16.2.4 恶意代码注入\n16.2.5 服务器被攻破\n16.3了解与我们“打交道”的用户\n16.3.1 破解人员\n16.3.2 受影响机器的未知情用户\n16.3.3 对公司不满的员工\n16.3.4 硬件被盗\n16.3.5 我们自身\n16.4 代码的安全性\n16.4.1 过滤用户输入\n16.4.2 转义输出\n16.4.3 代码组织\n16.4.4 代码自身的问题\n16.4.5 文件系统因素\n16.4.6 代码稳定性和缺陷\n16.4.7 执行引号和exec\n16.5 Web服务器和PHP的安全性\n16.5.1 保持软件的更新\n16.5.2 查看php.ini文件\n16.5.3  Web服务器配置\n16.5.4 Web应用的商业主机服务\n16.6 数据库服务器的安全性\n16.6.1 用户和权限系统\n16.6.2发送数据至服务器\n16.6.3 连接服务器\n16.6.4 运行服务器\n16.7 保护网络\n16.7.1 安装防火墙\n16.7.2使用隔离区域（DMZ）\n16.7.3应对DoS和DDoS攻击\n16.8 计算机和操作系统的安全性\n16.8.1 保持操作系统的更新\n16.8.2只运行必须的软件\n16.8.3 服务器的物理安全性\n16.9 灾难计划\n16.10 下一章\n第17章 使用PHP和MySQL实现身份验证\n17.1 识别访问者\n17.2 实现访问控制\n17.2.1 保存密码\n17.2.2 密码的加密\n17.2.3 保护多个网页\n17.3 使用基本身份验证\n17.4 在PHP中使用基本身份验证\n17.5 在Apache的.htaccess文件中使用基本身份验证\n17.6 使用mod_auth_mysql身份验证\n17.6.1 安装mod_auth_mysql\n17.6.2 使用mod_auth_mysql\n17.7 创建自定义身份验证\n17.8 进一步学习\n17.9 下一章\n第18章 使用PHP和MySQL实现安全事务\n18.1 提供安全的事务处理\n18.1.1 用户机器\n18.1.2 Internet\n18.1.3 我们的系统\n18.2 使用加密套接字层（SSL）\n18.3 屏蔽用户的输入\n18.4 提供安全存储\n18.5 存储信用卡号码\n18.6 在PHP中使用加密技术\n18.6.1 安装GPG\n18.6.2 测试GPG\n18.7 进一步学习\n18.8 下一章\n第四篇 PHP的高级技术\n第19章 与文件系统和服务器的交互\n19.1 文件上载\n19.1.1 文件上载的HTML代码\n19.1.2 编写处理文件的PHP\n19.1.3 避免常见上载问题\n19.2 使用目录函数\n19.2.1 从目录读取\n19.2.2 获得当前目录的信息\n19.2.3 创建和删除目录\n19.3 与文件系统的交互\n19.3.1 获取文件信息\n19.3.2 更改文件属性\n19.3.3 创建、删除和移动文件\n19.4 使用程序执行函数\n19.5 与环境变量交互：getenv()和putenv()\n19.6 进一步学习\n19.7 下一章\n第20章 使用网络函数和协议函数\n20.1 了解可供使用的协议\n20.2 发送和读取电子邮件\n20.3 使用其他Web站点的数据\n20.4 使用网络查找函数\n20.5 备份或镜像一个文件\n20.5.1 使用FTP备份或镜像一个文件\n20.5.2 上传文件\n20.5.3 避免超时\n20.5.4 使用其他的FTP函数\n20.6 进一步学习\n20.7 下一章\n第21章 日期和时间的管理\n21.1 在PHP中获取日期和时间\n21.1.1 使用date()函数\n21.1.2 使用UNIX时间戳\n21.1.3 使用getdate()函数\n21.1.4 使用checkdate()函数检验日期有效性\n21.1.5 格式化时间戳\n21.2 在PHP日期格式和MySQL日期格式之间进行转换\n21.3 在PHP中计算日期\n21.4 在MySQL中计算日期\n21.5 使用微秒\n21.6 使用日历函数\n21.7 进一步学习\n21.8 下一章\n第22章 创建图像\n22.1 在PHP中设置图像支持\n22.2 理解图像格式\n22.2.1 JPEG\n22.2.2 PNG\n22.2.3 WBMP\n22.2.4 GIF\n22.3 创建图像\n22.3.1 创建一个背景图像\n22.3.2 在图像上绘图或打印文本\n22.3.3 输出最终图形\n22.3.4 清理\n22.4 在其他页面中使用自动生成的图像\n22.5 使用文本和字体创建图像\n22.5.1 创建基本画布\n22.5.2 将文本调整到适合按钮\n22.5.3 放置文本\n22.5.4 将文本写到按钮上\n22.5.5 完成\n22.6 绘制图像与用图表描绘数据\n22.7 使用其他的图像函数\n22.8 进一步学习\n22.9 下一章\n第23章 在PHP中使用会话控制\n23.1 什么是会话控制\n23.2 理解基本的会话功能\n23.2.1 什么是cookie\n23.2.2 通过PHP设置cookie\n23.2.3 在会话中使用cookie\n23.2.4 存储会话 ID\n23.3 实现简单的会话\n23.3.1 开始一个会话\n23.3.2 注册一个会话变量\n23.3.3 使用会话变量\n23.3.4 注销变量与销毁会话\n23.4 创建一个简单的会话例子\n23.5 配置会话控制\n23.6 通过会话控制实现身份验证\n23.7 进一步学习\n23.8 下一章\n第24章 其他有用的特性\n24.1 使用eval()函数对字符串求值\n24.2 终止执行：die和exit\n24.3 序列化变量和对象\n24.4 获取PHP环境信息\n24.4.1 找到所加载的PHP扩展部件\n24.4.2 识别脚本所有者\n24.4.3 确定脚本最近修改时间\n24.5 暂时改变运行时环境\n24.6 源代码加亮\n24.7 在命令行中使用PHP\n24.8 下一章\n第五篇 创建实用的PHP和MySQL项目\n第25章 在大型项目中使用PHP和MySQL\n25.1 在Web开发中应用软件工程\n25.2 规划和运行Web应用程序项目\n25.3 重用代码\n25.4 编写可维护代码\n25.4.1 编码标准\n25.4.2 分解代码\n25.4.3 使用标准的目录结构\n25.4.4 文档化和共享内部函数\n25.5 实现版本控制\n25.6 选择一个开发环境\n25.7 项目的文档化\n25.8 建立原型\n25.9 将逻辑和内容分离\n25.10 优化代码\n25.10.1 使用简单优化\n25.10.2 使用Zend产品\n25.11 测试\n25.12 进一步学习\n25.13 下一章\n第26章 调试\n26.1 编程错误\n26.1.1 语法错误\n26.1.2 运行时错误\n26.1.3 逻辑错误\n26.2 使用变量帮助调试\n26.3 错误报告级别\n26.4 改变错误报告设置\n26.5 触发自定义错误\n26.6 巧妙地处理错误\n26.7 下一章\n第27章 建立用户身份验证机制和个性化设置\n27.1 解决方案的组成\n27.1.1 用户识别和个性化设置\n27.1.2 保存书签\n27.1.3 推荐书签\n27.2 解决方案概述\n27.3 实现数据库\n27.4 实现基本的网站\n27.5 实现用户身份验证\n27.5.1 注册\n27.5.2 登录\n27.5.3 登出\n27.5.4 修改密码\n27.5.5 重设遗忘的密码\n27.6 实现书签的存储和检索\n27.6.1 添加书签\n27.6.2 显示书签\n27.6.3 删除书签\n27.7 实现书签推荐\n27.8 考虑可能的扩展\n27.9 下一章\n第28章 创建一个购物车\n28.1 解决方案的组成\n28.1.1 创建一个在线目录\n28.1.2 在用户购买商品的时候记录购买行为\n28.1.3 实现一个付款系统\n28.1.4 创建一个管理界面\n28.2 解决方案概述\n28.3 实现数据库\n28.4 实现在线目录\n28.4.1 列出目录\n28.4.2 列出一个目录中的所有图书\n28.4.3 显示图书详细信息\n28.5 实现购物车\n28.5.1 使用show_cart.php脚本\n28.5.2 浏览购物车\n28.5.3 将物品添加到购物库\n28.5.4 保存更新后的购物车\n28.5.5 打印标题栏摘要\n28.5.6 结账\n28.6 实现付款\n28.7 实现一个管理界面\n28.8 扩展该项目\n28.9 使用一个已有系统\n28.10 下一章\n第29章 创建一个基于Web的电子邮件服务系统\n29.1 解决方案的组成\n29.1.1 电子邮件协议：POP3和IMAP\n29.1.2 PHP对POP3和IMAP的支持\n29.2 解决方案概述\n29.3 建立数据库\n29.4 了解脚本架构\n29.5 登录与登出\n29.6 建立账户\n29.6.1 创建一个新账户\n29.6.2 修改已有账户\n29.6.3 删除账户\n29.7 阅读邮件\n29.7.1 选择账户\n29.7.2 查看邮箱内容\n29.7.3 阅读邮件消息\n29.7.4 查看消息标题\n29.7.5 删除邮件\n29.8 发送邮件\n29.8.1 发送一则新消息\n29.8.2 回复或转发邮件\n29.9 扩展这个项目\n29.10 下一章\n第30章 创建一个邮件列表管理器\n30.1 解决方案的组成\n30.1.1 建立列表和订阅者数据库\n30.1.2 上载新闻信件\n30.1.3 发送带附件的邮件\n30.2 解决方案概述\n30.3 建立数据库\n30.4 定义脚本架构\n30.5 实现登录\n30.5.1 新账户的创建\n30.5.2 登录\n30.6 用户函数的实现\n30.6.1 查看列表\n30.6.2 查看邮件列表信息\n30.6.3 查看邮件列表存档\n30.6.4 订阅与取消订阅\n30.6.5 更改账户设置\n30.6.6 更改密码\n30.6.7 登出\n30.7 管理功能的实现\n30.7.1 创建新的邮件列表\n30.7.2 上载新的新闻信件\n30.7.3 多文件上载的处理\n30.7.4 预览新闻信件\n30.7.5 发送邮件\n30.8 扩展这个项目\n30.9 下一章\n第31章 创建一个Web论坛\n31.1 理解流程\n31.2 解决方案的组成\n31.3 解决方案概述\n31.4 数据库的设计\n31.5 查看文章的树型结构\n31.5.1 展开和折叠\n31.5.2 显示文章\n31.5.3 使用treenode类\n31.6 查看单个的文章\n31.7 添加新文章\n31.8 添加扩充\n31.9 使用一个已有的系统\n31.10 下一章\n第32章 生成PDF格式的个性化文档\n32.1 项目概述\n32.1.1 评估文档格式\n32.2 解决方案的组成\n32.2.1 问题与回答系统\n32.2.2 文档生成软件\n32.3 解决方案概述\n32.3.1 提问\n32.3.2 给答题评分\n32.3.3 生成RTF证书\n32.3.4 从模板生成PDF证书\n32.3.5 使用PDFlib生成PDF文档\n32.3.6 使用PDFlib的一个“Hello World”程序\n32.3.7 用PDFlib生成证书\n32.4 处理标题的问题\n32.5 扩展该项目\n32.6 下一章\n第33章 使用XML和SOAP来连接Web服务\n33.1 项目概述：使用XML和Web服务\n33.1.1 理解XML\n33.1.2 理解Web服务\n33.2 解决方案的组成\n33.2.1 使用Amazon的Web服务接口\n33.2.2  XML的解析：REST响应\n33.2.3 在PHP中使用SOAP\n33.2.4 缓存\n33.3 解决方案概述\n33.3.1 核心应用程序\n33.3.2 显示特定种类的图书\n33.3.3 获得一个AmazonResultSet类\n33.3.4 使用REST发送和接收请求\n33.3.5 使用SOAP发送和接收请求\n33.3.6 缓存请求返回的数据\n33.3.7 创建购物车\n33.3.8 到Amazon付账\n33.4 安装项目代码\n33.5 扩展这个项目\n33.6 进一步学习\n第34 章使用Ajax构建Web 2.0应用\n34.1 Ajax 是什么？\n34.1.1 HTTP请求和响应\n34.1. 2 DHTML和XHTML\n34.1.3 级联样式单（CSS）\n34.1.4 客户端编程\n34.1.5 服务器端编程\n34.1.6 XML和XSLT\n34.2 Ajax基础\n34.2.1 XMLHTTPRequest对象\n34.2.2 与服务器通信\n34.2.3 处理服务器响应\n34.2.4 整合应用\n34.3 在以前的项目添加Ajax元素\n34.3.1在PHPBookmark应用中添加Ajax元素\n34.4 进一步学习\n34.4.1 进一步了解文档对象模型（DOM）\n34.4.2 Ajax应用可用的JavaScript函数库\n34.4.3 Ajax开发人员网站\n第六篇 附录\n附录A 安装PHP及MySQL\n附录B Web资源\n第1章 PHP快速入门教程\n第2章 数据的存储与检索\n第3章 使用数组\n第4章 字符串操作与正则表达式\n第5章 代码重用与函数编写\n第6章 面向对象的PHP\n第7章 错误和异常处理', '9787111262817', '{\"small\":\"https://img3.doubanio.com/spic/s3773304.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s3773304.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s3773304.jpg\"}', '{\"id\":\"28671\",\"title\":\"开发人员专业技术丛书\"}', '1', '[{\"count\":936,\"name\":\"PHP\",\"title\":\"PHP\"},{\"count\":453,\"name\":\"web开发\",\"title\":\"web开发\"},{\"count\":407,\"name\":\"mysql\",\"title\":\"mysql\"},{\"count\":223,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":137,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":134,\"name\":\"web\",\"title\":\"web\"},{\"count\":86,\"name\":\"LAMP\",\"title\":\"LAMP\"},{\"count\":67,\"name\":\"Programming\",\"title\":\"Programming\"}]');
INSERT INTO `book` VALUES ('117', '7111401921', 'PHP核心技术与最佳实践', '', '', 'https://api.douban.com/v2/book/20370984', 'https://book.douban.com/subject/20370984/', 'https://img3.doubanio.com/mpic/s27276430.jpg', '列旭松，陈文', '', '机械工业出版社', '2013-1-1', '平装', '89.00元', '522', '列旭松，资深PHP技术工程师，精通PHP及其相关技术，对PHP内核原理有较深入的理解，开发经验丰富。曾自主开发了关键字匹配服务器和消息队列SquirrelMQ。平时喜欢开发一些实用的PHP扩展，如PHP字典扩展（红黑树算法）和PHP索引扩展（B+树算法）。精通C语言，同时对Web服务器的架构和优化、高并发服务端编程、Redis和Memcached等技术有深入的研究和认识。活跃于PHPChina和ChinaUnix等专业社区，担任PHPChina论坛内核版块版主。\n陈文，资深PHP技术工程师，精通PHP及其相关技术，尤其擅长于PHP框架开发和应用架构。他还是一位资深的Java开发工程师，具有Fortran、Scala和C++语言的开发和使用背景，在传统软件和互联网开发领域都有丰富的实战经验。此外，他还擅长TCP/IP编程、多线程与并发程序设计、网络协议分析、数据库性能优化以及各种缓存技术，熟悉MySQL和Oracle等关系数据库产品。现从事网络安全软件开发，以及移动SI业务开发。对语言特性和软件设计思想有独到的见解，追求代码之美和高效率程序开发，爱好钻研底层技术，崇尚和提倡“以理论指导实践”。尤其爱好数学，认为数学是培养和锻炼思维和逻辑能力的重要工具，对算法有一定研究。长期活跃在PHPChina、ITeye和看雪论坛等社区，在PHPChina社区担任版主。', '《PHP核心技术与最佳实践》是一本致力于为希望成为中高级PHP程序员的读者提供高效而有针对性指导的经典著作。系统归纳和深刻解读了PHP开发中的编程思想、底层原理、核心技术、开发技巧、编码规范和最佳实践。全书分为5个部分：第一部分（1～2章）从不同的角度阐述了面向对象软件设计思想的核心概念、技术和原则，分析了面向对象的特性、设计模式的理念，指出了如何设计低耦合、高可扩展性的软件，等等；第二部分（3～6章）详细讲解了PHP中正则表达式的规范和使用技巧，PHP网络编程的原理、方法、技巧和一些重要的操作，PDO、数据库应用优化，数据库设计和MySQL的高级应用，PHP扩展引擎的原理与实践；第三部分（第7章）拨云见日，围绕PHP扩展开发进行了细致而深入的探讨，解析了PHP的底层实现和Zend虚拟机API，并用PHP扩展开发的实例带领读者走进PHP的底层世界，旨在让读者对PHP性能优化、底层原理进行深入的理解。第四部分（8～11章）重点讨论了缓存的设计、Memcached的原理与实践、NoSQL数据库Redis源码分析与应用实践、高性能PHP网站的架构和设计等内容；第五部分（12～14章）详细讲解了PHP代码的调试和测试、Hash算法和数据库的实现，以及PHP的编码规范，旨在帮助读者提高开发效率，养成良好编程习惯。', '前言\n第1章　面向对象思想的核心概念\n1.1　面向对象的“形”与“本”\n1.1.1　对象的“形”\n1.1.2　对象的“本”\n1.1.3　对象与数组\n1.1.4　对象与类\n1.2　魔术方法的应用\n1.2.1　set和get方法\n1.2.2　call和callStatic方法\n1.2.3　toString方法\n1.3　继承与多态\n1.3.1　类的组合与继承\n1.3.2　各种语言中的多态\n1.4　面向接口编程\n1.4.1　接口的作用\n1.4.2　对PHP接口的思考\n1.5　反射\n1.5.1　如何使用反射API\n1.5.2　反射有什么作用\n1.6　异常和错误处理\n1.6.1　如何使用异常处理机制\n1.6.2　怎样看PHP的异常\n1.6.3　PHP中的错误级别\n1.6.4　PHP中的错误处理机制\n1.7　本章小结\n第2章　面向对象的设计原则\n2.1　面向对象设计的五大原则\n2.1.1　单一职责原则\n2.1.2　接口隔离原则\n2.1.3　开放-封闭原则\n2.1.4　替换原则\n2.1.5　依赖倒置原则\n2.2　一个面向对象留言本的实例\n2.3　面向对象的思考\n2.4　本章小结\n第3章　正则表达式基础与应用\n3.1　认识正则表达式\n3.1.1　PHP中的正则函数\n3.1.2　正则表达式的组成\n3.1.3　测试工具的使用\n3.2　正则表达式中的元字符\n3.2.1　什么是元字符\n3.2.2　起始和结束元字符\n3.2.3　点号\n3.2.4　量词\n3.3　正则表达式匹配规则\n3.3.1　字符组\n3.3.2　转义\n3.3.3　反义\n3.3.4　分支\n3.3.5　分组\n3.3.6　反向引用\n3.3.7　环视\n3.3.8　贪婪懒惰匹配模式\n3.4　构造正则表达式\n3.4.1　正则表达式的逻辑关系\n3.4.2　运算符优先级\n3.4.3　正则表达式的常用模式\n3.5　正则在实际开发中的应用\n3.5.1　移动手机校验\n3.5.2　匹配E-mail地址\n3.5.3　转义在数据安全中的应用\n3.5.4　URL重写与搜索引擎优化\n3.5.5　删除文件中的空行和注释\n3.6　正则表达式的效率与优化\n3.7　本章小结\n第4章　PHP网络技术及应用\n4.1　HTTP协议详解\n4.1.1　HTTP协议与SPDY协议\n4.1.2　HTTP协议如何工作\n4.1.3　HTTP应用：模拟灌水机器人\n4.1.4　垃圾信息防御措施\n4.2　抓包工具\n4.2.1　抓包工具分类\n4.2.2　Fiddler功能与原理\n4.2.3　安装Fiddler\n4.2.4　Fiddler基本界面\n4.2.5　使用Fiddler进行HTTP断点调试\n4.3　Socket进程通信机制及应用\n4.3.1　进程通信相关概念\n4.3.2　Socket演示：实现服务器端与客户端的交互\n4.3.3　Socket函数原型\n4.3.4　PHP中的Socket函数\n4.3.5　Socket交互应用：使用Socket抓取数据\n4.4　cURL工具及应用\n4.4.1　建立cURL请求的基本步骤\n4.4.2　检查cURL错误和获取返回信息\n4.4.3　在cURL中伪造头信息\n4.4.4　在cURL中用POST方法发送数据\n4.4.5　使用cURL上传文件\n4.4.6　cURL批处理\n4.4.7　cURL设置项\n4.4.8　网络应用：使用cURL抓取腾讯微博\n4.5　简单邮件传输协议SMTP\n4.5.1　SMTP协议如何工作\n4.5.2　SMTP协议常用命令\n4.5.3　SMTP协议应用：使用Socket发送邮件\n4.6　WebService的前世今生\n4.6.1　WebService简介\n4.6.2　认识PHPRPC协议\n4.6.3　Web服务的实现模式\n4.6.4　简单对象访问协议SOAP\n4.6.5　调试工具soapUI\n4.7　Cookie详解\n4.7.1　Cookie的基本概念及设置\n4.7.2　PHP和JavaScript对Cookie的操作\n4.7.3　Cookie存储机制及应用\n4.7.4　Cookie跨域与P3P协议\n4.7.5　本地存储localStorage\n4.8　Session详解\n4.8.1　Session的基本概念及设置\n4.8.2　Session的工作原理\n4.8.3　Session入库\n4.8.4　Cookie与Session问答\n4.9　本章小结\n第5章　PHP与数据库基础\n5.1　什么是PDO\n5.1.1　PDO预定义类\n5.1.2　如何使用PDO\n5.1.3　PDO参数绑定与预编译\n5.1.4　PDO事务处理\n5.1.5　PDO的效率问题\n5.2　数据库应用优化\n5.2.1　基本语句优化10个原则\n5.2.2　索引与性能分析\n5.2.3　服务器和配置的优化\n5.2.4　MySQL瓶颈及应对措施\n5.3　数据库设计\n5.3.1　范式与反范式\n5.3.2　数据库分区\n5.3.3　分表的应用\n5.4　MySQL的高级应用\n5.4.1　MySQL自增长序列\n5.4.2　MySQL视图\n5.4.3　MySQL存储过程和事件调度\n5.4.4　用MySQL模拟消息队列\n5.4.5　SQL注入漏洞与防范\n5.5　本章小结\n第6章　PHP模板引擎的原理与实践\n6.1　代码分层的思想\n6.2　实现一个简单的模板引擎骨架\n6.2.1　搭建模板引擎基础类骨架\n6.2.2　编译类骨架\n6.2.3　测试模板引擎\n6.3　模板引擎的编译\n6.3.1　实现变量标签\n6.3.2　实现foreach标签\n6.3.3　实现if…else标签\n6.3.4　对PHP原生语法的支持\n6.4　完善模板引擎\n6.4.1　模板缓存机制的实现\n6.4.2　调试和缓存清理\n6.4.3　如何使用模板\n6.5　常用模板引擎\n6.5.1　Discuz模板引擎\n6.5.2　Smarty模板引擎\n6.5.3　DedeCms模板引擎\n6.5.4　Blitz模板引擎\n6.5.5　模板引擎的一些思考\n6.6　本章小结\n第7章　PHP扩展开发\n7.1　为什么要开发PHP扩展\n7.2　搭建PHP扩展框架\n7.2.1　PHP源代码目录\n7.2.2　ext_skel工具\n7.2.3　Windows平台环境配置\n7.2.4　Linux平台环境配置\n7.2.5　PHP的生命周期\n7.3　PHP内核中的变量\n7.3.1　PHP变量在内核中的存储方式\n7.3.2　PHP内核变量访问宏\n7.3.3　引用计数器与写时复制\n7.4　PHP内核中的HashTable分析\n7.4.1　PHP内核HashTable的数据结构\n7.4.2　HashTable的代码实现\n7.5　Zend API详解与扩展编写\n7.5.1　什么是Zend引擎\n7.5.2　Zend引擎内存管理\n7.5.3　PHP扩展的架构\n7.5.4　接收用户传递的参数\n7.5.5　在PHP扩展中创建变量\n7.5.6　在PHP扩展中为变量赋值\n7.5.7　错误和输出API\n7.5.8　运行时信息函数\n7.5.9　调用用户自定义函数\n7.5.10　PHP配置项\n7.5.11　创建常量的宏\n7.6　编写一个完整的扩展\n7.6.1　链表结构的实现\n7.6.2　创建PHP扩展框架\n7.6.3　编写代码\n7.6.4　编译安装扩展\n7.6.5　测试扩展\n7.7　本章小结\n第8章　缓存详解\n8.1　认识缓存\n8.1.1　为什么使用缓存\n8.1.2　命中率\n8.1.3　缓存更新策略\n8.1.4　缓存最大数据量\n8.2　文件缓存\n8.2.1　文件缓存机制\n8.2.2　文件缓存开源产品Secache\n8.3　Opcode缓存\n8.3.1　eAccelerator下载及使用\n8.3.2　如何查看Opcode\n8.4　客户端缓存\n8.4.1　客户端缓存规则\n8.4.2　HTTP协议中的缓存使用\n8.4.3　HTTP缓存实例\n8.4.4　HTML 5中的Application Cache\n8.5　Web服务器缓存\n8.5.1　Apache缓存\n8.5.2　Nginx缓存\n8.6　本章小结\n第9章　Memcached使用与实践\n9.1　为什么要用Memcached\n9.2　Memcached的安装及使用\n9.2.1　安装Memcached服务器\n9.2.2　安装Memcached客户端\n9.2.3　使用memcache扩展访问Memcached服务器\n9.2.4　使用Memcached加速Web应用\n9.3　深入了解Memcached\n9.3.1　Memcached如何支持高并发\n9.3.2　使用Slab分配算法保存数据\n9.3.3　删除过期item\n9.3.4　使用LRU算法淘汰数据\n9.3.5　Memcached多线程模型\n9.4　Memcached分布式布置方案\n9.4.1　普通Hash分布\n9.4.2　一致性Hash分布\n9.4.3　一致性Hash分布算法实例\n9.5　本章小结\n第10章　Redis使用与实践\n10.1　Redis的安装及使用\n10.1.1　Redis安装步骤\n10.1.2　修改Redis配置文件\n10.1.3　运行Redis服务器\n10.1.4　key相关命令\n10.1.5　Redis支持的数据类型\n10.1.6　Redis排序命令详解\n10.2　事务处理\n10.2.1　事务处理原理\n10.2.2　事务处理实现\n10.3　持久化\n10.3.1　内存快照\n10.3.2　日志追加\n10.4　主从同步\n10.4.1　Redis主从同步原理\n10.4.2　Slave端的工作流程\n10.4.3　Master端的工作流程\n10.5　虚拟内存\n10.5.1　配置文件信息\n10.5.2　开启VM的后台操作\n10.5.3　Redis Object和VM Pointer\n10.5.4　交换过程\n10.5.5　阻塞式VM\n10.5.6　非阻塞式VM\n10.6　扩展库phpredis安装及使用\n10.7　Redis应用实践\n10.7.1　使用消息队列发布微博\n10.7.2　Redis替代文件存储Session\n10.8　深入了解Redis内核\n10.8.1　内存淘汰\n10.8.2　对象引用计数器\n10.8.3　自动关闭超时连接\n10.8.4　清除过期数据\n10.9　本章小结\n第11章　高性能网站架构方案\n11.1　如何优化网站响应时间\n11.1.1　吞吐率\n11.1.2　压力测试\n11.1.3　持久连接\n11.2　MySQL响应速度提高方案：HandlerSocket\n11.2.1　HandlerSocket工作原理\n11.2.2　HandlerSocket安装和配置\n11.2.3　PHP-HandlerSocket性能测试\n11.3　MySQL稳定性提高方案：主从复制\n11.3.1　主从复制工作原理\n11.3.2　主从复制配置\n11.3.3　连接主从服务器\n11.4　Web应用加速方案：Varnish\n11.4.1　传统代理与反向代理\n11.4.2　Varnish安装和配置\n11.4.3　Varnish性能测试\n11.4.4　修改缓存规则\n11.4.5　监控Varnish运行状态\n11.5　异步计算方案：Gearman\n11.5.1　Gearman工作原理\n11.5.2　安装Gearman和PHP扩展\n11.5.3　使用Gearman异步发送邮件\n11.6　本章小结\n第12章　代码调试和测试\n12.1　调试PHP代码\n12.1.1　PHP调试函数\n12.1.2　断点调试与变量跟踪工具Xdebug\n12.2　前端调试\n12.2.1　Firebug调试API\n12.2.2　使用Firebug调试DOM结构\n12.2.3　使用Firebug调试JavaScript\n12.2.4　使用Fiddler调试远程服务器上的文件\n12.3　日志管理\n12.3.1　PHP日志\n12.3.2　Apache服务器日志\n12.3.3　MySQL日志\n12.4　代码性能测试技术\n12.4.1　时间点测试\n12.4.2　文件查看工具WinCacheGrind\n12.4.3　性能测试注意事项\n12.5　单元测试\n12.5.1　单元测试框架PHPUnit的安装\n12.5.2　结合NetBeans使用PHPUnit进行单元测试\n12.5.3　PHPUnit中的断言函数\n12.5.4　PHPUnit常用方法\n12.5.5　PHPUnit常用注解\n12.6　压力测试\n12.6.1　使用JMeter压力测试HTTP\n12.6.2　压力测试MySQL\n12.6.3　JMeter+Badboy组合测试\n12.7　本章小结\n第13章　Hash算法与数据库实现\n13.1　Hash函数\n13.2　Hash算法\n13.2.1　直接取余法\n13.2.2　乘积取整法\n13.2.3　经典Hash算法Times33\n13.3　Hash表\n13.3.1　Hash表结构\n13.3.2　使用PHP实现Hash表\n13.3.3　Hash表冲突\n13.3.4　拉链法解决冲突\n13.4　一个小型数据库的实现\n13.4.1　pack函数的用法\n13.4.2　unpack函数的用法\n13.4.3　索引文件和数据文件\n13.4.4　数据库接口方法\n13.4.5　源代码解析\n13.4.6　测试代码\n13.5　本章小结\n第14章　PHP编码规范\n14.1　文件格式\n14.1.1　文件标记\n14.1.2　文件和目录命名\n14.1.3　文件目录结构\n14.2　命名规范\n14.2.1　变量命名\n14.2.2　类及接口命名\n14.2.3　数据库命名\n14.2.4　习惯与约定\n14.3　注释规范\n14.3.1　程序注释\n14.3.2　文件注释\n14.3.3　类接口注释\n14.3.4　方法和函数注释\n14.3.5　标注的使用\n14.4　代码风格\n14.4.1　缩进和空格\n14.4.2　语句断行\n14.4.3　更好的习惯\n14.5　本章小结', '9787111401926', '{\"small\":\"https://img3.doubanio.com/spic/s27276430.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s27276430.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s27276430.jpg\"}', 'undefined', '1', '[{\"count\":237,\"name\":\"PHP\",\"title\":\"PHP\"},{\"count\":75,\"name\":\"web开发\",\"title\":\"web开发\"},{\"count\":50,\"name\":\"核心技术\",\"title\":\"核心技术\"},{\"count\":32,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":30,\"name\":\"性能优化\",\"title\":\"性能优化\"},{\"count\":23,\"name\":\"互联网\",\"title\":\"互联网\"},{\"count\":23,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":22,\"name\":\"php\",\"title\":\"php\"}]');
INSERT INTO `book` VALUES ('118', '7115299226', '响应式Web设计', 'Responsive Web Design with HTML5 and CSS3', 'HTML5和CSS3实战', 'https://api.douban.com/v2/book/20390374', 'https://book.douban.com/subject/20390374/', 'https://img1.doubanio.com/mpic/s27359269.jpg', 'Ben Frain', '王永强', '人民邮电出版社', '2013-1-1', '平装', '49.00元', '231', 'Ben Frain是一名具有十多年经验的网页设计师和前端工程师，直接与世界各地的客户和设计机构并肩工作。同时他还是一名技术记者，定期为一些关注Mac平台、前沿科技、网页设计和航空技术的刊物撰稿。\n在此之前，他曾是一名怀才不遇的（而且谦虚谨慎的）电视演员，毕业于索尔福德大学的媒体与表演专业。他写了四部（自认为）同样被低估的剧本，而且始终心怀能卖出一部的信念（尽管不像最初那么强烈了）。\n工作之余，在身体（和妻子）允许的情况下，他喜欢玩室内足球。 他的个人网站是www.benfrain.com，Twitter地址是twitter.com/benfrain。', '随着iPad mini的发布，又一个新的屏幕尺寸诞生了。用不着全面统计，你就会发现移动互联网时代众多的屏幕规格，从智能手机的3、4、5英寸，到平板电脑的7、8、9、10英寸，再到笔记本和台式机的13至30英寸，绝非目前单一的固定或流式布局所能应付。于是，响应式设计应运而生，而且它也将成为移动互联网时代前端设计与开发人员的一门必修课。\n本书堪称学习响应式Web设计的难得佳作。它不仅全面、细致、图文并茂地介绍了响应式设计相关的技术，比如媒体查询、流式布局、弹性媒体和弹性字体等，还把近几年来Web设计领域公认的最佳设计理念有机地融入到了实例当中，比如移动先行（Mobile First）、渐进增强、平稳退化、无障碍设计等。更加难得的是，本书以设计跨屏幕的网页（响应式设计）为出发点，以点带面，把如今Web设计领域两大标准的最新版本HTML5和CSS3也纳入其中，读者在掌握先进设计方法的同时也能掌握最新的设计技术（比如使用新的HTML5结构化语义标记、嵌入媒体、响应式视频，以及CSS3的新选择器、特效、过渡、变形和动画等），从而可以免除重复学习新标准之苦，让自己一步跨入Web设计领域的最前沿。无论你想学习响应式Web设计，还是学习HTML5和CSS3的实际应用，本书都能满足你的需要，是毋庸置疑的明智之选。\n说到底，响应式Web设计并非一门独立的技术，而只是现有技术的一个组合应用。只要有一点HTML和CSS基础的读者都能顺利地掌握它。对于中、高级的前端设计和开发人员，翻阅本书也有助于理清自己的知识脉络，对这个新的设计理念获得更全面、深入的理解和把握。\n习惯移动阅读的读者，可访问图灵社区，购买本书电子版：http://www.ituring.com.cn/book/1055', '第1章 　HTML5、CSS3及响应式设计入门　　1\n1.1 　为什么智能手机很重要（而老版的IE不再重要）　　2\n1.2 　响应式设计一定是最佳选择吗　　3\n1.3 　响应式网页设计的定义　　3\n1.4 　为什么要在响应式设计上停滞不前　　4\n1.5 　响应式网页设计示例　　4\n1.5.1 　下载视口调试工具　　4\n1.5.2 　在线创意源泉　　11\n1.6 　为什么HTML5很优秀　　12\n1.6.1 　省时省力　　12\n1.6.2 　新增了语义化标签元素　　13\n1.7 　CSS3为响应式设计和更多创新奠定了基础　　13\n1.7.1 　底线：CSS3不破坏任何东西　　14\n1.7.2 　CSS3如何解决日常设计问题　　14\n1.8 　看呐，不用图片　　17\n1.9 　HTML5和CSS3现在就能用吗　　20\n1.10 　响应式网页设计不是灵丹妙药　　20\n1.11 　引导客户：网站不必在所有浏览器中表现一致　　21\n1.12 　小结　　22\n第2章 　媒体查询：支持不同的视口　　23\n2.1 　现在就能使用媒体查询　　23\n2.2 　为什么响应式设计需要媒体查询　　24\n2.2.1 　媒体查询语法　　24\n2.2.2 　 媒体查询能检测那些特性　　26\n2.2.3 　用媒体查询改造我们的设计　　27\n2.2.4 　加载媒体查询的最佳方法　　27\n2.3 　我们的第一个响应式设计　　27\n2.3.1 　我们的设计是固定宽度的，不要惊讶　　28\n2.3.2 　响应式设计中要保证图片尽可能精简　　32\n2.3.3 　小视口下的内容剪切　　33\n2.4 　阻止移动浏览器自动调整页面大小　　34\n2.5 　针对不同视口宽度修正设计　　37\n2.6 　响应式设计中内容始终优先　　38\n2.7 　媒体查询只是必要条件之一　　42\n2.8 　小结　　42\n第3章 　拥抱流式布局　　43\n3.1 　固定布局经不起未来考验　　43\n3.2 　为什么响应式设计需要百分比布局　　44\n3.3 　将网页从固定布局修改为百分比布局　　44\n3.3.1 　需要牢记的公式　　45\n3.3.2 　设置百分比元素的上下文　　47\n3.3.3 　必须时刻牢记上下文　　52\n3.4 　用em替换px　　54\n3.5 　弹性图片　　56\n3.5.1 　让图片随视口缩放　　56\n3.5.2 　为特定图片指定特定规则　　58\n3.5.3 　给弹性图片设置阈值　　59\n3.5.4 　超级全能的max-width属性　　61\n3.6 　为不同的屏幕尺寸提供不同的图片　　61\n3.7 　流动网格布局和媒体查询的默契配合　　66\n3.8 　CSS网格系统　　66\n3.9 　小结　　72\n第4章 　响应式设计中的HTML5　　73\n4.1 　HTML5的哪些部分现在就能用　　73\n4.1.1 　大多数网站可以用HTML5编写　　74\n4.1.2 　腻子脚本和Modernizr　　74\n4.2 　如何编写HTML5网页　　75\n4.2.1 　HTML5的精简之道　　76\n4.2.2 　HTML5标签的合理写法　　76\n4.2.3 　伟大的<a>标签万岁　　77\n4.2.4 　HTML的废弃零件　　77\n4.3 　HTML5的全新语义化元素　　78\n4.3.1 　<section>　　78\n4.3.2 　<nav>　　79\n4.3.3 　<article>　　79\n4.3.4 　<aside>　　79\n4.3.5 　<hgroup>　　79\n4.3.6 　<header>　　81\n4.3.7 　<footer>　　81\n4.3.8 　<address>　　81\n4.4 　HTML5结构元素的实际用法　　81\n4.5 　HTML5的文本级语义元素　　87\n4.5.1 　<b>　　88\n4.5.2 　<em>　　88\n4.5.3 　<i>　　88\n4.5.4 　在页面中应用文本层语义元素　　88\n4.6 　遵循WAI-ARIA实现无障碍站点　　90\n4.7 　在HTML5中嵌入媒体　　93\n4.8 　用HTML5的方法为页面添加视频或音频　　93\n4.8.1 　提供备用的媒体源文件　　95\n4.8.2 　针对老版本浏览器的备用方案　　95\n4.8.3 　和标签的用法基本一致　　96\n4.9 　响应式视频　　96\n4.10 　离线Web应用　　99\n4.10.1 　离线Web应用概述　　99\n4.10.2 　让网页可离线使用　　99\n4.10.3 　理解manifest文件　　100\n4.10.4 　页面被自动加载到离线缓存　　101\n4.10.5 　版本注释的用途　　101\n4.10.6 　离线访问网站　　101\n4.10.7 　离线Web应用的故障诊断　　102\n4.11 　小结　　103\n第5章 　CSS3：选择器、字体和颜色模式　　104\n5.1 　CSS3给前端开发人员带来了什么　　104\n5.1.1 　Internet Explorer 6到8对CSS3的支持　　105\n5.1.2 　使用CSS3设计和开发页面　　105\n5.2 　CSS规则解析　　105\n5.3 　私有前缀及其用法　　106\n5.4 　快速而有效的CSS技巧　　108\n5.4.1 　CSS3多栏布局　　108\n5.4.2 　文字换行　　110\n5.5 　CSS3的新增选择器及其用法　　111\n5.5.1 　CSS3属性选择器　　111\n5.5.2 　CSS3结构伪类　　113\n5.5.3 　对伪元素的修正　　122\n5.6 　自定义网页字体　　123\n5.6.1 　@font-face规则　　124\n5.6.2 　使用@font-face嵌入网页字体　　124\n5.7 　帮帮我，标题模糊怎么办　　127\n5.8 　新的CSS3颜色格式和透明度　　129\n5.8.1 　RGB颜色　　130\n5.8.2 　HSL颜色　　131\n5.8.3 　针对IE6、IE7和IE8提供备用颜色值　　132\n5.8.4 　透明通道　　132\n5.9 　小结　　134\n第6章 　用CSS3创造令人惊艳的美　　135\n6.1 　文字阴影　　136\n6.1.1 　HEX、HSL或RGB颜色都可以　　136\n6.1.2 　px、em或rem都行　　136\n6.1.3 　取消文字阴影　　138\n6.1.4 　制作浮雕文字阴影效果　　139\n6.1.5 　多重文字阴影　　140\n6.2 　盒阴影　　140\n6.2.1 　内阴影　　141\n6.2.2 　多重阴影　　142\n6.3 　背景渐变　　143\n6.3.1 　线性背景渐变　　144\n6.3.2 　径向背景渐变　　147\n6.3.3 　重复渐变　　149\n6.4 　背景渐变图案　　151\n6.5 　CSS3的响应性　　153\n6.6 　组合使用CSS3属性　　155\n6.7 　多重背景图片　　159\n6.7.1 　背景图片大小　　161\n6.7.2 　背景图片位置　　161\n6.7.3 　背景属性的缩写语法　　161\n6.8 　更多CSS特性　　162\n6.9 　可缩放图标：响应式设计中的完美选择　　162\n6.10 　小结　　163\n第7章 　CSS3过渡、变形和动画　　164\n7.1 　什么是CSS3过渡以及如何使用它　　164\n7.1.1 　过渡相关的属性　　166\n7.1.2 　响应式网站中的有趣过渡　　168\n7.2 　CSS3的2D变形　　169\n7.3 　尝试CSS3的3D变形　　174\n7.3.1 　分析3D变形效果　　176\n7.3.2 　3D变形尚未成熟　　178\n7.4 　CSS3动画效果　　179\n7.5 　小结　　185\n第8章 　用HTML5和CSS3征服表单　　186\n8.1 　HTML5表单　　186\n8.1.1 　理解HTML5表单中的元素　　188\n8.1.2 　placeholder　　189\n8.1.3 　required　　189\n8.1.4 　autofocus　　190\n8.1.5 　autocomplete　　191\n8.1.6 　list（及对应的datalist元素）　　191\n8.1.7 　HTML5的新输入类型　　192\n8.1.8 　日期和时间输入类型　　198\n8.2 　如何给不支持新特性的浏览器打补丁　　203\n8.3 　使用CSS3美化HTML5表单　　204\n8.4 　小结　　210\n第9章 　解决跨浏览器问题　　211\n9.1 　渐进增强与优雅降级　　215\n9.2 　该不该修复老版本IE　　216\n9.2.1 　统计数据（再看看世界的变化）　　216\n9.2.2 　个人选择　　216\n9.3 　前端的瑞士军刀：Modernizr　　217\n9.3.1 　使用Modernizr辅助修正样式问题　　219\n9.3.2 　使用Modernizr让老版本IE支持HTML5元素　　221\n9.3.3 　给IE6、7、8追加min/max媒体查询功能　　222\n9.3.4 　使用Modernizr按需加载资源　　223\n9.4 　必要时将导航链接转换为下拉菜单　　225\n9.5 　高分辨率设备（未来趋势）　　228\n9.6 　小结　　231\n', '9787115299222', '{\"small\":\"https://img1.doubanio.com/spic/s27359269.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s27359269.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s27359269.jpg\"}', 'undefined', '1', '[{\"count\":224,\"name\":\"响应式设计\",\"title\":\"响应式设计\"},{\"count\":168,\"name\":\"Web开发\",\"title\":\"Web开发\"},{\"count\":142,\"name\":\"html5\",\"title\":\"html5\"},{\"count\":125,\"name\":\"前端开发\",\"title\":\"前端开发\"},{\"count\":100,\"name\":\"CSS3\",\"title\":\"CSS3\"},{\"count\":67,\"name\":\"HTML5\",\"title\":\"HTML5\"},{\"count\":38,\"name\":\"web\",\"title\":\"web\"},{\"count\":37,\"name\":\"css3\",\"title\":\"css3\"}]');
INSERT INTO `book` VALUES ('119', '7115338361', 'HTML5权威指南', 'The definitive guide to HTML5', '', 'https://api.douban.com/v2/book/25786074', 'https://book.douban.com/subject/25786074/', 'https://img3.doubanio.com/mpic/s27169241.jpg', '[美] Adam Freeman', '谢廷晟,牛化成,刘美英', '人民邮电出版社', '2014-1', '平装', '129.00元', '848', 'Adam Freeman\n曾在多家名企担任高级职务，现为畅销技术图书作家，著有多部C#、.NET和Java方面的大部头作品。其中《ASP.NET 4高级程序设计（第4版）》、《精通ASP.NET MVC 3框架（第3版）》销量均在同品种中名列前茅，备受读者推崇。《HTML5权威指南》是Freeman专门为网页开发新手和网页设计师打造的经典参考书，这本书秉承作者的一贯风格，幽默风趣、简约凝练、逻辑性强，是广大Web开发人员的必读经典。', '《HTML5 权威指南》是系统学习网页设计的权威参考图书。本书分为五部分：第一部分介绍学习本书的预备知识和HTML、CSS 和JavaScript 的最新进展；第二部分讨论HTML 元素，并详细说明了HTML5中新增和修改的元素；第三部分阐述CSS，涵盖了所有控制内容样式的CSS 选择器和属性，并辅以大量代码示例和图示；第四部分介绍DOM，剖析如何用JavaScript 操纵HTML 内容；第五部分讲解Ajax、多媒体和canvas 元素等HTML5 高级特性。\n本书面向初学者和中等水平Web 开发人员，是牢固掌握HTML5、CSS3 和JavaScript 的必读之作。', '第一部分　开篇\n第1章　HTML5背景知识　　1\n1.1 　HTML的历史　　2\n1.1.1 　JavaScript出场　　2\n1.1.2 　浏览器战争的结束　　3\n1.1.3 　插件称雄　　3\n1.1.4 　语义HTML浮出水面　　3\n1.1.5 　发展态势：HTML标准滞后于其使用　　4\n1.2 　HTML5简介　　4\n1.2.1 　新标准　　4\n1.2.2 　引入原生多媒体支持　　5\n1.2.3 　引入可编程内容　　5\n1.2.4 　引入语义Web　　6\n1.3 　HTML5现况　　6\n1.3.1 　浏览器对HTML5的支持情况　　6\n1.3.2 　网站对HTML5的支持情况　　6\n1.4 　本书结构　　6\n1.5 　HTML5的更多信息　　7\n1.6 　小结　　7\n第2章　准备工作　　8\n2.1 　挑选浏览器　　8\n2.2 　挑选HTML编辑器　　9\n2.3 　挑选Web服务器　　9\n2.4 　获取Node.js　　9\n2.5 　获取示例代码　　10\n2.6 　小结　　10\n第3章　初探HTML　　11\n3.1 　使用元素　　12\n3.1.1 　了解本章用到的元素　　13\n3.1.2 　使用空元素　　14\n3.1.3 　使用自闭合标签　　14\n3.1.4 　使用虚元素　　14\n3.2 　使用元素属性　　16\n3.2.1 　一个元素应用多个属性　　16\n3.2.2 　使用布尔属性　　16\n3.2.3 　使用自定义属性　　17\n3.3 　创建HTML文档　　17\n3.3.1 　外层结构　　18\n3.3.2 　元数据　　19\n3.3.3 　内容　　19\n3.3.4 　父元素、子元素、后代元素和兄弟元素　　20\n3.3.5 　了解元素类型　　20\n3.4 　使用HTML实体　　21\n3.5 　HTML5全局属性　　21\n3.5.1 　accesskey属性　　21\n3.5.2 　class属性　　22\n3.5.3 　contenteditable属性　　25\n3.5.4 　contextmenu属性　　25\n3.5.5 　dir属性　　26\n3.5.6 　draggable属性　　26\n3.5.7 　dropzone属性　　26\n3.5.8 　hidden属性　　26\n3.5.9 　id属性　　28\n3.5.10 　lang属性　　29\n3.5.11 　spellcheck属性　　29\n3.5.12 　style属性　　30\n3.5.13 　tabindex属性　　30\n3.5.14 　title属性　　31\n3.6 　有用的HTML工具　　32\n3.7 　小结　　32\n第4章　初探CSS　　33\n4.1 　定义和应用样式　　33\n4.1.1 　了解本章所用的CSS属性　　34\n4.1.2 　使用元素内嵌样式　　34\n4.1.3 　使用文档内嵌样式　　35\n4.1.4 　使用外部样式表　　37\n4.2 　样式的层叠和继承　　40\n4.2.1 　浏览器样式　　40\n4.2.2 　用户样式　　41\n4.2.3 　样式如何层叠　　42\n4.2.4 　用重要样式调整层叠次序　　42\n4.2.5 　根据具体程度和定义次序解决同级样式冲突　　43\n4.2.6 　继承　　46\n4.3 　CSS中的颜色　　48\n4.4 　CSS中的长度　　49\n4.4.1 　绝对长度　　50\n4.4.2 　相对长度　　51\n4.5 　其他CSS单位　　56\n4.5.1 　使用CSS角度　　56\n4.5.2 　使用CSS时间　　57\n4.6 　测试CSS特性的支持情况　　57\n4.7 　有用的CSS工具　　57\n4.7.1 　浏览器样式报告　　57\n4.7.2 　用SelectorGadget生成选择器　　58\n4.7.3 　用LESS改进CSS　　59\n4.7.4 　使用CSS框架　　59\n4.8 　小结　　59\n第5章　初探JavaScript　　60\n5.1 　准备使用JavaScript　　61\n5.2 　使用语句　　62\n5.3 　定义和使用函数　　63\n5.3.1 　定义带参数的函数　　63\n5.3.2 　定义会返回结果的函数　　64\n5.4 　使用变量和类型　　65\n5.4.1 　使用基本类型　　66\n5.4.2 　创建对象　　67\n5.4.3 　使用对象　　69\n5.5 　使用JavaScript运算符　　73\n5.5.1 　相等和等同运算符　　73\n5.5.2 　显式类型转换　　76\n5.6 　使用数组　　78\n5.6.1 　使用数组字面量　　79\n5.6.2 　读取和修改数组内容　　80\n5.6.3 　枚举数组内容　　80\n5.6.4 　使用内置的数组方法　　81\n5.7 　处理错误　　81\n5.8 　比较undefined和null值　　83\n5.8.1 　检查变量或属性是否为undefined或null　　85\n5.8.2 　区分null和undefined　　85\n5.9 　常用的JavaScript工具　　86\n5.9.1 　使用JavaScript调试器　　86\n5.9.2 　使用JavaScript库　　86\n5.10 　小结　　87\n第二部分　HTML元素\n第6章　HTML5元素背景知识　　90\n6.1 　语义与呈现分离　　90\n6.2 　元素选用原则　　91\n6.2.1 　少亦可为多　　91\n6.2.2 　别误用元素　　91\n6.2.3 　具体为佳，一以贯之　　91\n6.2.4 　对用户不要想当然　　92\n6.3 　元素说明体例　　92\n6.4 　元素速览　　92\n6.4.1 　文档和元数据元素　　92\n6.4.2 　文本元素　　93\n6.4.3 　对内容分组　　94\n6.4.4 　划分内容　　95\n6.4.5 　制表　　95\n6.4.6 　创建表单　　96\n6.4.7 　嵌入内容　　96\n6.5 　未实现的元素　　97\n6.6 　小结　　97\n第7章　创建HTML文档　　98\n7.1 　构筑基本的文档结构　　99\n7.1.1 　DOCTYPE元素　　99\n7.1.2 　html元素　　99\n7.1.3 　head元素　　100\n7.1.4 　body元素　　101\n7.2 　用元数据元素说明文档　　102\n7.2.1 　设置文档标题　　102\n7.2.2 　设置相对URL的解析基准　　103\n7.2.3 　用元数据说明文档　　104\n7.2.4 　定义CSS样式　　108\n7.2.5 　指定外部资源　　112\n7.3 　使用脚本元素　　116\n7.3.1 　script元素　　117\n7.3.2 　noscript元素　　123\n7.4 　小结　　125\n第8章　标记文字　　126\n8.1 　生成超链接　　127\n8.1.1 　生成指向外部的超链接　　128\n8.1.2 　使用相对URL　　129\n8.1.3 　生成内部超链接　　129\n8.1.4 　设定浏览环境　　130\n8.2 　用基本的文字元素标记内容　　131\n8.2.1 　表示关键词和产品名称　　131\n8.2.2 　加以强调　　132\n8.2.3 　表示外文词语或科技术语　　133\n8.2.4 　表示不准确或校正　　134\n8.2.5 　表示重要的文字　　135\n8.2.6 　为文字添加下划线　　136\n8.2.7 　添加小号字体内容　　137\n8.2.8 　添加上标和下标　　138\n8.3 　换行　　139\n8.3.1 　强制换行　　139\n8.3.2 　指明可以安全换行的建议位置　　141\n8.4 　表示输入和输出　　142\n8.5 　使用标题引用、引文、定义和缩写　　143\n8.5.1 　表示缩写　　143\n8.5.2 　定义术语　　144\n8.5.3 　引用来自他处的内容　　145\n8.5.4 　引用其他作品的标题　　146\n8.6 　使用语言元素　　147\n8.6.1 　ruby、rt和rp元素　　147\n8.6.2 　bdo元素　　149\n8.6.3 　bdi元素　　150\n8.7 　其他文本元素　　152\n8.7.1 　表示一段一般性的内容　　152\n8.7.2 　突出显示文本　　153\n8.7.3 　表示添加和删除的内容　　155\n8.7.4 　表示时间和日期　　156\n8.8 　小结　　157\n第9章　组织内容　　158\n9.1 　为什么要对内容分组　　158\n9.2 　建立段落　　159\n9.3 　使用div元素　　161\n9.4 　使用预先编排好格式的内容　　163\n9.5 　引用他处内容　　164\n9.6 　添加主题分隔　　166\n9.7 　将内容组织为列表　　169\n9.7.1 　ol元素　　169\n9.7.2 　ul元素　　171\n9.7.3 　li元素　　172\n9.7.4 　生成说明列表　　173\n9.7.5 　生成自定义列表　　174\n9.8 　使用插图　　176\n9.9 　小结　　178\n第10章　文档分节　　179\n10.1 　添加基本的标题　　179\n10.2 　隐藏子标题　　182\n10.3 　生成节　　185\n10.4 　添加首部和尾部　　188\n10.5 　添加导航区域　　191\n10.6 　使用article　　194\n10.7 　生成附注栏　　198\n10.8 　提供联系信息　　201\n10.9 　生成详情区域　　202\n10.10 　小结　　205\n第11章　表格元素　　206\n11.1 　生成基本的表格　　206\n11.2 　添加表头单元格　　209\n11.3 　为表格添加结构　　211\n11.3.1 　表示表头和表格主题　　212\n11.3.2 　添加表脚　　214\n11.4 　制作不规则表格　　216\n11.5 　把表头与单元格关联起来　　220\n11.6 　为表格添加标题　　221\n11.7 　处理列　　223\n11.8 　设置表格边框　　228\n11.9 　小结　　230\n第12章　表单　　231\n12.1 　制作基本表单　　232\n12.1.1 　定义表单　　233\n12.1.2 　查看表单数据　　234\n12.2 　配置表单　　236\n12.2.1 　配置表单的action属性　　236\n12.2.2 　配置HTTP方法属性　　237\n12.2.3 　配置数据编码　　237\n12.2.4 　控制表单的自动完成功能　　239\n12.2.5 　指定表单反馈信息的目标显示位置　　240\n12.2.6 　设置表单名称　　242\n12.3 　在表单中添加说明标签　　242\n12.4 　自动聚焦到某个input元素　　244\n12.5 　禁用单个input元素　　245\n12.6 　对表单元素编组　　246\n12.6.1 　为fieldset元素添加说明标签　　248\n12.6.2 　用fieldset禁用整组input元素　　249\n12.7 　使用button元素　　250\n12.7.1 　用button元素提交表单　　251\n12.7.2 　用button元素重置表单　　252\n12.7.3 　把button作为一般元素使用　　253\n12.8 　使用表单外的元素　　254\n12.9 　小结　　254\n第13章　定制input元素　　255\n13.1 　用input元素输入文字　　256\n13.1.1 　设定元素大小　　256\n13.1.2 　设置初始值和占位式提示　　258\n13.1.3 　使用数据列表　　259\n13.1.4 　生成只读或被禁用的文本框　　262\n13.1.5 　指定文字方向数据的名称　　263\n13.2 　用input元素输入密码　　263\n13.3 　用input元素生成按钮　　266\n13.4 　用input元素为输入数据把关　　267\n13.4.1 　用input元素获取数值　　268\n13.4.2 　用input元素获取指定范围内的数值　　270\n13.4.3 　用input元素获取布尔型输入　　271\n13.4.4 　用input元素生成一组固定选项　　273\n13.4.5 　用input元素获取有规定格式的字符串　　275\n13.4.6 　用input元素获取时间和日期　　277\n13.4.7 　用input元素获取颜色值　　279\n13.5 　用input元素获取搜索用词　　281\n13.6 　用input元素生成隐藏的数据项　　282\n13.7 　用input元素生成图像按钮和分区响应图　　284\n13.8 　用input元素上传文件　　286\n13.9 　小结　　288\n第14章　其他表单元素及输入验证　　289\n14.1 　使用其他表单元素　　289\n14.1.1 　生成选项列表　　289\n14.1.2 　输入多行文字　　294\n14.1.3 　表示计算结果　　296\n14.1.4 　生成公开/私有密钥对　　297\n14.2 　使用输入验证　　298\n14.2.1 　确保用户提供了一个值　　299\n14.2.2 　确保输入值位于某个范围内　　300\n14.2.3 　确保输入值与指定模式匹配　　301\n14.2.4 　确保输入值是电子邮箱地址或URL　　303\n14.3 　禁用输入验证　　304\n14.4 　小结　　305\n第15章　嵌入内容　　306\n15.1 　嵌入图像　　306\n15.1.1 　在超链接里嵌入图像　　308\n15.1.2 　创建客户端分区响应图　　310\n15.2 　嵌入另一张HTML文档　　313\n15.3 　通过插件嵌入内容　　315\n15.3.1 　使用embed元素　　315\n15.3.2 　使用object和param元素　　317\n15.4 　object元素的其他用途　　319\n15.4.1 　使用object元素嵌入图像　　319\n15.4.2 　使用object元素创建分区响应图　　320\n15.4.3 　将object元素作为浏览上下文环境　　320\n15.5 　嵌入数字表现形式　　321\n15.5.1 　显示进度　　321\n15.5.2 　显示范围里的值　　322\n15.6 　其他嵌入元素　　324\n15.6.1 　嵌入音频和视频　　324\n15.6.2 　嵌入图形　　324\n15.7 　小结　　324\n第三部分　CSS\n第16章　理解CSS　　326\n16.1 　CSS标准化　　326\n16.2 　盒模型　　327\n16.3 　选择器简明参考　　328\n16.4 　属性简明参考　　329\n16.4.1 　边框和背景属性　　329\n16.4.2 　盒模型属性　　331\n16.4.3 　布局属性　　332\n16.4.4 　文本属性　　332\n16.4.5 　过渡、动画和变换属性　　333\n16.4.6 　其他属性　　334\n16.5 　小结　　334\n第17章　使用CSS选择器（第Ⅰ部分）　　335\n17.1 　使用CSS基本选择器　　335\n17.1.1 　选择所有元素　　336\n17.1.2 　根据类型选择元素　　337\n17.1.3 　根据类选择元素　　338\n17.1.4 　根据ID选择元素　　340\n17.1.5 　根据属性选择元素　　341\n17.2 　复合选择器　　344\n17.2.1 　并集选择器　　344\n17.2.2 　后代选择器　　345\n17.2.3 　选择子元素　　347\n17.2.4 　选择兄弟元素　　349\n17.3 　使用伪元素选择器　　351\n17.3.1 　使用::first-line选择器　　351\n17.3.2 　使用::first-letter选择器　　352\n17.3.3 　使用:before和:after选择器　　353\n17.3.4 　使用CSS计数器　　354\n17.4 　小结　　356\n第18章　使用CSS选择器（第Ⅱ部分）　　357\n18.1 　使用结构性伪类选择器　　357\n18.1.1 　使用根元素选择器　　358\n18.1.2 　使用子元素选择器　　359\n18.1.3 　使用:nth-child选择器　　363\n18.2 　使用UI伪类选择器　　364\n18.2.1 　选择启用或禁用元素　　364\n18.2.2 　选择已勾选的元素　　365\n18.2.3 　选择默认元素　　366\n18.2.4 　选择有效和无效的input元素　　367\n18.2.5 　选择限定范围的input元素　　369\n18.2.6 　选择必需和可选的input元素　　370\n18.3 　使用动态伪类选择器　　371\n18.3.1 　使用:link和:visited选择器　　371\n18.3.2 　使用:hover选择器　　372\n18.3.3 　使用:active选择器　　373\n18.3.4 　使用:focus选择器　　374\n18.4 　其他伪类选择器　　375\n18.4.1 　使用否定选择器　　376\n18.4.2 　使用:empty选择器　　376\n18.4.3 　使用:lang选择器　　377\n18.4.4 　使用:target选择器　　377\n18.5 　小结　　379\n第19章　使用边框和背景　　380\n19.1 　应用边框样式　　380\n19.1.1 　定义边框宽度　　381\n19.1.2 　定义边框样式　　382\n19.1.3 　为一条边应用边框样式　　383\n19.1.4 　使用border简写属性　　384\n19.1.5 　创建圆角边框　　385\n19.1.6 　将图像用做边框　　388\n19.2 　设置元素的背景　　392\n19.2.1 　设置背景颜色和图像　　392\n19.2.2 　设置背景图像的尺寸　　394\n19.2.3 　设置背景图像位置　　395\n19.2.4 　设置元素的背景附着方式　　396\n19.2.5 　设置背景图像的开始位置和裁剪样式　　397\n19.2.6 　使用background简写属性　　399\n19.3 　创建盒子阴影　　400\n19.4 　应用轮廓　　403\n19.5 　小结　　405\n第20章　使用盒模型　　406\n20.1 　为元素应用内边距　　407\n20.2 　为元素应用外边距　　409\n20.3 　控制元素的尺寸　　410\n20.3.1 　设置一定尺寸的盒子　　412\n20.3.2 　设置最小和最大尺寸　　413\n20.4 　处理溢出内容　　414\n20.5 　控制元素的可见性　　417\n20.6 　设置元素的盒类型　　419\n20.6.1 　认识块级元素　　420\n20.6.2 　认识行内元素　　421\n20.6.3 　认识行内?块级元素　　422\n20.6.4 　认识插入元素　　423\n20.6.5 　隐藏元素　　426\n20.7 　创建浮动盒　　427\n20.8 　小结　　433\n第21章　创建布局　　434\n21.1 　定位内容　　434\n21.1.1 　设置定位类型　　435\n21.1.2 　设置元素的层叠顺序　　437\n21.2 　创建多列布局　　439\n21.3 　创建弹性盒布局　　442\n21.3.1 　创建简单的弹性盒　　444\n21.3.2 　伸缩多个元素　　446\n21.3.3 　处理垂直空间　　447\n21.3.4 　处理最大尺寸　　448\n21.4 　创建表格布局　　450\n21.5 　小结　　453\n第22章　设置文本样式　　454\n22.1 　应用基本文本样式　　454\n22.1.1 　对齐文本　　455\n22.1.2 　处理空白　　457\n22.1.3 　指定文本方向　　460\n22.1.4 　指定单词、字母、行之间的间距　　461\n22.1.5 　控制断词　　462\n22.1.6 　首行缩进　　464\n22.2 　文本装饰与大小写转换　　465\n22.3 　创建文本阴影　　467\n22.4 　使用字体　　468\n22.4.1 　选择字体　　469\n22.4.2 　设置字体大小　　470\n22.4.3 　设置字体样式和粗细　　472\n22.5 　使用Web字体　　473\n22.6 　小结　　475\n第23章　过渡、动画和变换　　476\n23.1 　使用过渡　　477\n23.1.1 　创建反向过渡　　480\n23.1.2 　选择中间值的计算方式　　481\n23.2 　使用动画　　483\n23.2.1 　使用关键帧　　486\n23.2.2 　设置重复方向　　488\n23.2.3 　理解结束状态　　490\n23.2.4 　初始布局时应用动画　　491\n23.2.5 　重用关键帧　　492\n23.2.6 　为多个元素应用多个动画　　493\n23.2.7 　停止和启动动画　　495\n23.3 　使用变换　　497\n23.3.1 　应用变换　　497\n23.3.2 　指定元素变换的起点　　498\n23.3.3 　将变换作为动画和过渡处理　　500\n23.4 　小结　　501\n第24章　其他CSS属性和特性　　502\n24.1 　设置元素的颜色和透明度　　502\n24.1.1 　设置前景色　　502\n24.1.2 　设置元素的透明度　　504\n24.2 　设置表格样式　　505\n24.2.1 　合并表格边框　　505\n24.2.2 　配置独立边框　　507\n24.2.3 　处理空单元格　　508\n24.2.4 　设置标题的位置　　509\n24.2.5 　指定表格布局　　511\n24.3 　设置列表样式　　512\n24.3.1 　设置列表标记类型　　513\n24.3.2 　使用图像作为列表标记　　514\n24.3.3 　设置列表标记的位置　　515\n24.4 　设置光标样式　　517\n24.5 　小结　　518\n第四部分　使用DOM\n第25章　理解DOM　　520\n25.1 　理解文档对象模型　　520\n25.2 　理解DOM Level和兼容性　　522\n25.3 　DOM快速查询　　524\n25.3.1 　Document的成员　　524\n25.3.2 　Window的成员　　525\n25.3.3 　HTMLElement的成员　　527\n25.3.4 　DOM里的CSS属性　　529\n25.3.5 　DOM中的事件　　531\n25.4 　小结　　532\n第26章　使用Document对象　　533\n26.1 　使用Document元数据　　536\n26.1.1 　获取文档信息　　536\n26.1.2 　使用Location对象　　537\n26.1.3 　读取和写入cookie　　541\n26.1.4 　理解就绪状态　　542\n26.1.5 　获取DOM的实现情况　　543\n26.2 　获取HTML元素对象　　544\n26.2.1 　使用属性获取元素对象　　545\n26.2.2 　使用数组标记获取已命名元素　　546\n26.2.3 　搜索元素　　548\n26.2.4 　合并进行链式搜索　　550\n26.3 　在DOM树里导航　　552\n26.4 　小结　　554\n第27章　使用Window对象　　555\n27.1 　获取Window对象　　555\n27.2 　获取窗口信息　　556\n27.3 　与窗口进行交互　　558\n27.4 　对用户进行提示　　559\n27.5 　获取基本信息　　561\n27.6 　使用浏览器历史　　561\n27.6.1 　在浏览历史中导航　　562\n27.6.2 　在浏览历史里插入条目　　564\n27.6.3 　为不同的文档添加条目　　566\n27.6.4 　在浏览历史中保存复杂状态　　567\n27.6.5 　替换浏览历史中的条目　　570\n27.7 　使用跨文档消息传递　　570\n27.8 　使用计时器　　574\n27.9 　小结　　576\n第28章　使用DOM元素　　577\n28.1 　使用元素对象　　577\n28.1.1 　使用类　　579\n28.1.2 　使用元素属性　　582\n28.2 　使用Text对象　　586\n28.3 　修改模型　　588\n28.3.1 　创建和删除元素　　589\n28.3.2 　复制元素　　591\n28.3.3 　移动元素　　592\n28.3.4 　比较元素对象　　593\n28.3.5 　使用HTML片段　　595\n28.3.6 　向文本块插入元素　　600\n28.4 　小结　　601\n第29章　为DOM元素设置样式　　602\n29.1 　使用样式表　　602\n29.1.1 　获得样式表的基本信息　　603\n29.1.2 　使用媒介限制　　605\n29.1.3 　禁用样式表　　607\n29.1.4 　CSSRuleList对象的成员　　608\n29.2 　使用元素样式　　611\n29.3 　使用CSSStyleDeclaration对象　　613\n29.3.1 　使用便捷属性　　613\n29.3.2 　使用常规属性　　616\n29.3.3 　使用细粒度的CSS DOM对象　　620\n29.4 　使用计算样式　　623\n29.5 　小结　　625\n第30章　使用事件　　626\n30.1 　使用简单事件处理器　　627\n30.1.1 　实现简单的内联事件处理器　　627\n30.1.2 　实现一个简单的事件处理函数　　629\n30.2 　使用DOM和事件对象　　630\n30.2.1 　按类型区分事件　　633\n30.2.2 　理解事件流　　634\n30.2.3 　使用可撤销事件　　641\n30.3 　使用HTML事件　　642\n30.3.1 　文档和窗口事件　　642\n30.3.2 　使用鼠标事件　　643\n30.3.3 　使用键盘焦点事件　　645\n30.3.4 　使用键盘事件　　647\n30.3.5 　使用表单事件　　649\n30.4 　小结　　649\n第31章　使用元素专属对象　　650\n31.1 　文档和元数据对象　　650\n31.1.1 　base元素　　650\n31.1.2 　body元素　　650\n31.1.3 　link元素　　651\n31.1.4 　meta元素　　651\n31.1.5 　script元素　　651\n31.1.6 　style元素　　652\n31.1.7 　title元素　　652\n31.1.8 　其他文档和元数据元素　　652\n31.2 　文本元素　　652\n31.2.1 　a元素　　652\n31.2.2 　del和ins元素　　653\n31.2.3 　q元素　　653\n31.2.4 　time元素　　653\n31.2.5 　其他文本元素　　654\n31.3 　分组元素　　654\n31.3.1 　blockquote元素　　654\n31.3.2 　li元素　　654\n31.3.3 　ol元素　　654\n31.3.4 　其他分组元素　　655\n31.4 　区块元素　　655\n31.4.1 　details元素　　655\n31.4.2 　其他区块元素　　655\n31.5 　表格元素　　655\n31.5.1 　col和colgroup元素　　655\n31.5.2 　table元素　　656\n31.5.3 　thead、tbody和tfoot元素　　656\n31.5.4 　th元素　　657\n31.5.5 　tr元素　　657\n31.5.6 　其他表格元素　　657\n31.6 　表单元素　　657\n31.6.1 　button元素　　657\n31.6.2 　datalist元素　　658\n31.6.3 　fieldset元素　　658\n31.6.4 　form元素　　658\n31.6.5 　input元素　　659\n31.6.6 　label元素　　660\n31.6.7 　legend元素　　661\n31.6.8 　optgroup元素　　661\n31.6.9 　option元素　　661\n31.6.10 　output元素　　661\n31.6.11 　select元素　　662\n31.6.12 　textarea元素　　663\n31.7 　内容元素　　663\n31.7.1 　area元素　　664\n31.7.2 　embed元素　　664\n31.7.3 　iframe元素　　664\n31.7.4 　img元素　　665\n31.7.5 　map元素　　665\n31.7.6 　meter元素　　665\n31.7.7 　object元素　　666\n31.7.8 　param元素　　666\n31.7.9 　progress元素　　667\n31.8 　小结　　667\n第五部分　高级功能\n第32章　使用Ajax（第Ⅰ部分）　　670\n32.1 　Ajax起步　　671\n32.1.1 　处理响应　　674\n32.1.2 　主流中的异类：应对Opera　　675\n32.2 　使用Ajax事件　　677\n32.3 　处理错误　　679\n32.3.1 　处理设置错误　　681\n32.3.2 　处理请求错误　　682\n32.3.3 　处理应用程序错误　　682\n32.4 　获取和设置标头　　683\n32.4.1 　覆盖请求的HTTP方法　　683\n32.4.2 　禁用内容缓存　　685\n32.4.3 　读取响应标头　　685\n32.5 　生成跨源Ajax请求　　687\n32.5.1 　使用Origin请求标头　　690\n32.5.2 　高级CORS功能　　691\n32.6 　中止请求　　691\n32.7 　小结　　693\n第33章　使用Ajax（第Ⅱ部分）　　694\n33.1 　准备向服务器发送数据　　694\n33.1.1 　定义服务器　　695\n33.1.2 　理解问题所在　　697\n33.2 　发送表单数据　　698\n33.3 　使用FormData对象发送表单数据　　701\n33.3.1 　创建FormData对象　　701\n33.3.2 　修改FormData对象　　702\n33.4 　发送JSON数据　　703\n33.5 　发送文件　　705\n33.6 　追踪上传进度　　707\n33.7 　请求并处理不同内容类型　　709\n33.7.1 　接收HTML片段　　709\n33.7.2 　接收XML数据　　712\n33.7.3 　接收JSON数据　　714\n33.8 　小结　　715\n第34章　使用多媒体　　716\n34.1 　使用video元素　　717\n34.1.1 　预先加载视频　　718\n34.1.2 　显示占位图像　　720\n34.1.3 　设置视频尺寸　　720\n34.1.4 　指定视频来源（和格式）　　721\n34.1.5 　track元素　　724\n34.2 　使用audio元素　　724\n34.3 　通过DOM操作嵌入式媒体　　726\n34.3.1 　获得媒体信息　　726\n34.3.2 　评估回放能力　　728\n34.3.3 　控制媒体回放　　730\n34.4 　小结　　733\n第35章　使用canvas元素（第Ⅰ部分）　　734\n35.1 　开始使用canvas元素　　735\n35.2 　获取画布的上下文　　736\n35.3 　绘制矩形　　737\n35.4 　设置画布绘制状态　　739\n35.4.1 　设置线条连接样式　　741\n35.4.2 　设置填充和笔触样式　　742\n35.4.3 　使用渐变　　743\n35.4.4 　使用径向渐变　　748\n35.4.5 　使用图案　　751\n35.5 　保存和恢复绘制状态　　753\n35.6 　绘制图像　　755\n35.6.1 　使用视频图像　　756\n35.6.2 　使用画布图像　　759\n35.7 　小结　　761\n第36章　使用canvas元素（第Ⅱ部分）　　762\n36.1 　用路径绘图　　762\n36.1.1 　用线条绘制路径　　763\n36.1.2 　绘制矩形　　766\n36.2 　绘制圆弧　　768\n36.2.1 　使用arcTo方法　　768\n36.2.2 　使用arc方法　　772\n36.3 　绘制贝塞尔曲线　　773\n36.3.1 　绘制三次贝塞尔曲线　　773\n36.3.2 　绘制二次贝塞尔曲线　　775\n36.4 　创建剪辑区域　　777\n36.5 　绘制文本　　778\n36.6 　使用特效和变换　　780\n36.6.1 　使用阴影　　780\n36.6.2 　使用透明度　　781\n36.6.3 　使用合成　　782\n36.6.4 　使用变换　　784\n36.7 　小结　　786\n第37章　使用拖放　　787\n37.1 　创建来源项目　　787\n37.2 　创建释放区　　791\n37.3 　使用DataTransfer对象　　794\n37.3.1 　根据数据过滤被拖动项目　　796\n37.3.2 　拖放文件　　797\n37.4 　小结　　801\n第38章　使用地理定位　　802\n38.1 　使用地理定位　　802\n38.2 　处理地理定位错误　　805\n38.3 　指定地理定位选项　　807\n38.4 　监控位置　　809\n38.5 　小结　　810\n第39章　使用Web存储　　811\n39.1 　使用本地存储　　811\n39.2 　使用会话存储　　815\n39.3 　小结　　819\n第40章　创建离线Web应用程序　　820\n40.1 　定义问题　　820\n40.2 　定义清单　　822\n40.3 　检测浏览器状态　　827\n40.4 　使用离线缓存　　828\n40.4.1 　制作更新　　832\n40.4.2 　获取更新　　832\n40.4.3 　应用更新　　833\n40.5 　小结　　834\n', '9787115338365', '{\"small\":\"https://img3.doubanio.com/spic/s27169241.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s27169241.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s27169241.jpg\"}', 'undefined', '1', '[{\"count\":93,\"name\":\"HTML5\",\"title\":\"HTML5\"},{\"count\":50,\"name\":\"前端开发\",\"title\":\"前端开发\"},{\"count\":23,\"name\":\"前端\",\"title\":\"前端\"},{\"count\":20,\"name\":\"Web前端\",\"title\":\"Web前端\"},{\"count\":17,\"name\":\"web开发\",\"title\":\"web开发\"},{\"count\":16,\"name\":\"Web\",\"title\":\"Web\"},{\"count\":15,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":9,\"name\":\"javascript\",\"title\":\"javascript\"}]');
INSERT INTO `book` VALUES ('120', '7115216878', '代码整洁之道', 'Clean Code: A Handbook of Agile Software Craftsmanship', '', 'https://api.douban.com/v2/book/4199741', 'https://book.douban.com/subject/4199741/', 'https://img3.doubanio.com/mpic/s4103991.jpg', '[美]Robert C. Martin', '韩磊', '人民邮电出版社', '2010-1-1', '平装', '59.00元', '388', 'Rober C．Martin，Object Mentor公司总裁。面向对象设计、模式、UML、敏捷方法学和极限编程领域的资深顾问。他是Designing Object-Oriented C++Applications Using the BoochMethod以及Jolt获奖图书Agile SoftwareDevelopment,Principles，Pattems，and Practices(中译版《敏捷软件开发：原则、模式与实践》)等畅销书作者。', '软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。\n本书提出一种观念：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，本书作者给出了一系列行之有效的整洁代码操作实践。这些实践在本书中体现为一条条规则（或称“启示”），并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。\n本书阅读对象为一切有志于改善代码质量的程序员及技术经理。书中介绍的规则均来自作者多年的实践经验，涵盖从命名到重构的多个编程方面，虽为一“家”之言，然诚有可资借鉴的价值。', '第1章　整洁代码　1\n1.1　要有代码　2\n1.2　糟糕的代码　2\n1.3　混乱的代价　3\n1.3.1　华丽新设计　4\n1.3.2　态度　4\n1.3.3　迷题　5\n1.3.4　整洁代码的艺术　5\n1.3.5　什么是整洁代码　6\n1.4　思想流派　10\n1.5　我们是作者　11\n1.6　童子军军规　12\n1.7　前传与原则　12\n1.8　小结　12\n1.9　文献　13\n第2章　有意义的命名　15\n2.1　介绍　15\n2.2　名副其实　16\n2.3　避免误导　17\n2.4　做有意义的区分　18\n2.5　使用读得出来的名称　19\n2.6　使用可搜索的名称　20\n2.7　避免使用编码　21\n2.7.1　匈牙利语标记法　21\n2.7.2　成员前缀　21\n2.7.3　接口和实现　22\n2.8　避免思维映射　22\n2.9　 类名　23\n2.10　方法名　23\n2.11　别扮可爱　23\n2.12　每个概念对应一个词　24\n2.13　别用双关语　24\n2.14　使用解决方案领域名称　25\n2.15　使用源自所涉问题领域的名称　25\n2.16　添加有意义的语境　25\n2.17　不要添加没用的语境　27\n2.18　最后的话　27\n第3章　函数　29\n3.1　短小　32\n3.2　只做一件事　33\n3.3　每个函数一个抽象层级　34\n3.4　switch语句　35\n3.5　使用描述性的名称　36\n3.6　函数参数　37\n3.6.1　一元函数的普遍形式　38\n3.6.2　标识参数　38\n3.6.3　二元函数　38\n3.6.4　三元函数　39\n3.6.5　参数对象　39\n3.6.6　参数列表　40\n3.6.7　动词与关键字　40\n3.7　无副作用　40\n3.8　分隔指令与询问　42\n3.9　使用异常替代返回错误码　42\n3.9.1　抽离Try/Catch代码块　43\n3.9.2　错误处理就是一件事　44\n3.9.3　Error.java依赖磁铁　44\n3.10　别重复自己　44\n3.11　结构化编程　45\n3.12　如何写出这样的函数　45\n3.13　小结　45\n3.14　SetupTeardownIncluder程序　46\n3.15　文献　48\n第4章　注释　49\n4.1　注释不能美化糟糕的代码　50\n4.2　用代码来阐述　51\n4.3　好注释　51\n4.3.1　法律信息　51\n4.3.2　提供信息的注释　51\n4.3.3　对意图的解释　52\n4.3.4　阐释　53\n4.3.5　警示　53\n4.3.6　TODO注释　54\n4.3.7　放大　54\n4.3.8　公共API中的Javadoc　55\n4.4　坏注释　55\n4.4.1　喃喃自语　55\n4.4.2　多余的注释　56\n4.4.3　误导性注释　58\n4.4.4　循规式注释　58\n4.4.5　日志式注释　59\n4.4.6　废话注释　59\n4.4.7　可怕的废话　61\n4.4.8　能用函数或变量时就别用注释　62\n4.4.9　位置标记　62\n4.4.10　括号后面的注释　62\n4.4.11　归属与署名　63\n4.4.12　注释掉的代码　63\n4.4.13　HTML注释　64\n4.4.14　非本地信息　64\n4.4.15　信息过多　65\n4.4.16　不明显的联系　65\n4.4.17　函数头　66\n4.4.18　非公共代码中的Javadoc　66\n4.4.19　范例　66\n4.5　文献　69\n第5章　格式　71\n5.1　格式的目的　72\n5.2　垂直格式　72\n5.2.1　向报纸学习　73\n5.2.2　概念间垂直方向上的区隔　73\n5.2.3　垂直方向上的靠近　74\n5.2.4　垂直距离　75\n5.2.5　垂直顺序　79\n5.3　横向格式　79\n5.3.1　水平方向上的区隔与靠近　80\n5.3.2　水平对齐　81\n5.3.3　缩进　82\n5.3.4　空范围　84\n5.4　团队规则　84\n5.5　鲍勃大叔的格式规则　85\n第6章　对象和数据结构　87\n6.1　数据抽象　87\n6.2　数据、对象的反对称性　89\n6.3　得墨忒耳律　91\n6.3.1　火车失事　91\n6.3.2　混杂　92\n6.3.3　隐藏结构　92\n6.4　数据传送对象　93\n6.5　小结　94\n6.6　文献　94\n第7章　错误处理　95\n7.1　使用异常而非返回码　96\n7.2　先写Try-Catch-Finally语句　97\n7.3　使用不可控异常　98\n7.4　给出异常发生的环境说明　99\n7.5　依调用者需要定义异常类　99\n7.6　定义常规流程　100\n7.7　别返回null值　101\n7.8　别传递null值　102\n7.9　小结　103\n7.10 文献　104\n第8章　边界　105\n8.1　使用第三方代码　106\n8.2　浏览和学习边界　107\n8.3　学习log4j　108\n8.4　学习性测试的好处不只是免费　110\n8.5　使用尚不存在的代码　110\n8.6　整洁的边界　111\n8.7　文献　112\n第9章　单元测试　113\n9.1　TDD三定律　114\n9.2　保持测试整洁　115\n9.3　整洁的测试　116\n9.3.1　面向特定领域的测试语言　118\n9.3.2　双重标准　119\n9.4　每个测试一个断言　121\n9.5　F.I.R.S.T.　122\n9.6　小结　123\n9.7　文献　124\n第10章　类　125\n10.1　类的组织　126\n10.2　类应该短小　126\n10.2.1　单一权责原则　128\n10.2.2　内聚　129\n10.2.3　保持内聚性就会得到许多短小的类　130\n10.3　为了修改而组织　136\n10.4　文献　139\n第11章　系统　141\n11.1　如何建造一个城市　142\n11.2　将系统的构造与使用分开　142\n11.2.1　分解main　143\n11.2.2　工厂　143\n11.2.3　依赖注入　144\n11.3　扩容　145\n11.4　Java代理　148\n11.5　纯Java AOP框架　150\n11.6　AspectJ的方面　152\n11.7　测试驱动系统架构　153\n11.8　优化决策　154\n11.9　明智使用添加了可论证价值的标准　154\n11.10　系统需要领域特定语言　154\n11.11　小结　155\n11.12　文献　155\n第12章　迭进　157\n12.1　通过迭进设计达到整洁目的　157\n12.2　简单设计规则1：运行所有测试　158\n12.3　简单设计规则2～4：重构　158\n12.4　不可重复　159\n12.5　表达力　161\n12.6　尽可能少的类和方法　162\n12.7　小结　162\n12.8　文献　162\n第13章　并发编程　163\n13.1　为什么要并发　164\n13.2　挑战　165\n13.3　并发防御原则　166\n13.3.1　单一权责原则　166\n13.3.2　推论：限制数据作用域　166\n13.3.3　推论：使用数据复本　167\n13.3.4　推论：线程应尽可能地独立　167\n13.4　了解Java库　167\n13.5　了解执行模型　168\n13.5.1　生产者-消费者模型　169\n13.5.2　读者-作者模型　169\n13.5.3　宴席哲学家　169\n13.6　警惕同步方法之间的依赖　169\n13.7　保持同步区域微小　170\n13.8　很难编写正确的关闭代码　170\n13.9　测试线程代码　171\n13.9.1　将伪失败看作可能的线程问题　171\n13.9.2　先使非线程代码可工作　171\n13.9.3　编写可插拔的线程代码　172\n13.9.4　编写可调整的线程代码　172\n13.9.5　运行多于处理器数量的线程　172\n13.9.6　在不同平台上运行　172\n13.9.7　装置试错代码　173\n13.9.8　硬编码　173\n13.9.9　自动化　174\n13.10　小结　175\n13.11　文献　175\n第14章　逐步改进　176\n14.1　Args的实现　177\n14.2　Args：草稿　183\n14.2.1　所以我暂停了　195\n14.2.2　渐进　195\n14.3　字符串参数　197\n14.4　小结　234\n第15章　JUnit内幕　235\n15.1　JUnit框架　236\n15.2　小结　249\n第16章　重构SerialDate　251\n16.1　首先，让它能工作　252\n16.2　让它做对　254\n16.3　小结　266\n16.4　文献　267\n第17章　味道与启发　269\n17.1　注释　270\n17.2　环境　271\n17.3　函数　271\n17.4　一般性问题　272\n17.5　Java　288\n17.6　名称　291\n17.7　测试　294\n17.8　小结　295\n17.9　文献　296\n附录A　并发编程II　297\nA.1　客户端/服务器的例子　297\nA.1.1　服务器　297\nA.1.2　添加线程代码　298\nA.1.3　观察服务器端　299\nA.1.4　小结　301\nA.2　执行的可能路径　301\nA.2.1　路径数量　302\nA.2.2　深入挖掘　303\nA.2.3　小结　305\nA.3　了解类库　305\nA.3.1　Executor框架　305\nA.3.2　非锁定的解决方案　306\nA.3.3　非线程安全类　307\nA.4　方法之间的依赖可能破坏并发代码　308\nA.4.1　容忍错误　309\nA.4.2　基于客户代码的锁定　309\nA.4.3　基于服务端的锁定　311\nA.5　提升吞吐量　312\nA.5.1　单线程条件下的吞吐量　313\nA.5.2　多线程条件下的吞吐量　313\nA.6　死锁　314\nA.6.1　互斥　315\nA.6.2　上锁及等待　315\nA.6.3　无抢先机制　315\nA.6.4　循环等待　315\nA.6.5　不互斥　316\nA.6.6　不上锁及等待　316\nA.6.7　满足抢先机制　317\nA.6.8　不做循环等待　317\nA.7　测试多线程代码　317\nA.8　测试线程代码的工具支持　320\nA.9　小结　320\nA.10 教程：完整代码范例　321\nA.10.1　客户端/服务器非线程代码　321\nA.10.2　使用线程的客户端/服务器代码　324\n附录B　org.jfree.date.SerialDate　327\n结束语　389', '9787115216878', '{\"small\":\"https://img3.doubanio.com/spic/s4103991.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s4103991.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s4103991.jpg\"}', 'undefined', '1', '[{\"count\":808,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":481,\"name\":\"代码整洁之道\",\"title\":\"代码整洁之道\"},{\"count\":277,\"name\":\"Programming\",\"title\":\"Programming\"},{\"count\":276,\"name\":\"软件工程\",\"title\":\"软件工程\"},{\"count\":257,\"name\":\"软件开发\",\"title\":\"软件开发\"},{\"count\":222,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":205,\"name\":\"编程实践\",\"title\":\"编程实践\"},{\"count\":195,\"name\":\"程序设计\",\"title\":\"程序设计\"}]');
INSERT INTO `book` VALUES ('121', '7111075757', '设计模式', 'Design Patterns: Elements of Reusable Object-Oriented Software', '可复用面向对象软件的基础', 'https://api.douban.com/v2/book/1052241', 'https://book.douban.com/subject/1052241/', 'https://img3.doubanio.com/mpic/s1074361.jpg', '[美] Erich Gamma,Richard Helm,Ralph Johnson,John Vlissides', '李英军,马晓星,蔡敏,刘建中 等', '机械工业出版社', '2000-9', '平装', '35.00元', '254', '四位作者均是国际公认的面向对象软件领域的专家。\nErich Gamma博士是瑞士苏黎士国际面向对象技术软件中心的技术主管。\nRichard Helm博士是澳大利亚悉尼IBM顾问集团公司面向对象技术公司的成员。\nRalph Johnson博士是Urbana-Champaign伊利诺大学计算机科学系成员。\nJohn Vlissides博士是位于纽约Hawthorne的IBN托马斯J.沃森研究中心的研究人员。', '这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。书中分类描述了一组设计良好、表达清楚的软件设计模式，这些模式在实用环境下特别有用。此书适合大学计算机专业的学生、研究生及相关人员参考。\n书中涉及的设计模式并不描述新的或未经证实的设计，只收录了那些在不同系统中多次使用过的成功设计。', '序言\n前言\n读者指南\n第1章 引言\n第2章 实例研究：设计一个文档编辑器\n第3章 创建型模式\n第4章 结构型模式\n第5章 行为模式\n第6章 结论\n附录A 词汇表\n附录B 图示符号指南\n附录C 基本类\n参考文献', '9787111075752', '{\"small\":\"https://img3.doubanio.com/spic/s1074361.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s1074361.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s1074361.jpg\"}', '{\"id\":\"1163\",\"title\":\"计算机科学丛书\"}', '1', '[{\"count\":2297,\"name\":\"设计模式\",\"title\":\"设计模式\"},{\"count\":787,\"name\":\"软件工程\",\"title\":\"软件工程\"},{\"count\":652,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":537,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":437,\"name\":\"软件开发\",\"title\":\"软件开发\"},{\"count\":340,\"name\":\"软件设计\",\"title\":\"软件设计\"},{\"count\":244,\"name\":\"程序设计\",\"title\":\"程序设计\"},{\"count\":238,\"name\":\"design\",\"title\":\"design\"}]');
INSERT INTO `book` VALUES ('122', '7111128060', 'C程序设计语言', 'The C Programming Language', '第 2 版·新版', 'https://api.douban.com/v2/book/1139336', 'https://book.douban.com/subject/1139336/', 'https://img3.doubanio.com/mpic/s1106934.jpg', '（美）Brian W. Kernighan,（美）Dennis M. Ritchie', '徐宝文,李志译,尤晋元审校', '机械工业出版社', '2004-1', '平装', '30.00元', '258', 'Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。', '在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。', '出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引', '9787111128069', '{\"small\":\"https://img3.doubanio.com/spic/s1106934.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s1106934.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s1106934.jpg\"}', '{\"id\":\"1163\",\"title\":\"计算机科学丛书\"}', '1', '[{\"count\":2422,\"name\":\"C\",\"title\":\"C\"},{\"count\":1618,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":1613,\"name\":\"c语言\",\"title\":\"c语言\"},{\"count\":972,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":844,\"name\":\"程序设计\",\"title\":\"程序设计\"},{\"count\":765,\"name\":\"经典\",\"title\":\"经典\"},{\"count\":521,\"name\":\"编程语言\",\"title\":\"编程语言\"},{\"count\":518,\"name\":\"programming\",\"title\":\"programming\"}]');
INSERT INTO `book` VALUES ('123', '7115288895', 'Linux命令行与shell脚本编程大全', 'Linux Command Line and Shell Scripting Bible, Second Edition', '', 'https://api.douban.com/v2/book/11589828', 'https://book.douban.com/subject/11589828/', 'https://img3.doubanio.com/mpic/s11171426.jpg', 'Richard Blum,Christine Bresnahan', '武海峰', '人民邮电出版社', '2012-9', '平装', '99.00元', '619', 'Richard Blum 系统和网络管理员，已经在IT行业工作了22年多。他管理过UNIX、Linux、Novell和微软服务器，用Linux shell脚本进行过自动化网络监测，并在大多数常见的Linux shell环境中写过脚本。他还是一名网络课程讲师，美国各地的多所大学和学院都采用他的Linux基础课程。除本书外，Richard还著有Professional Linux Programming等书。\nChristine Bresnahan 系统管理员，已经在IT行业工作了近30年。目前在印第安纳波利斯市的常春藤技术社区学院担任兼职教授，讲授Linux系统管理、Linux安全和Windows安全等课程。\n武海峰 Linux系统工程师，兴趣集中在GNU/Linux和移动互联应用，热衷于开源软件。曾在商业Linux厂商任职，从事移动设备操作系统集成和商业Linux发行版集成工作。', '本书是一本关于Linux 命令行与shell 脚本编程的全面教程。全书分为四部分：第一部分介绍Linuxshell 命令行；第二部分介绍shell 脚本编程基础；第三部分深入探讨shell 脚本编程的高级内容；第四部分介绍如何在现实环境中使用shell 脚本。本书不仅涵盖了详尽的动手教程和现实世界中的实用信息，还提供了与所学内容相关的参考信息和背景资料。\n本书内容全面，语言简练，示例丰富，适合于Linux 系统管理员及Linux 爱好者阅读参考。', '目　　录\n第一部分　Linux 命令行\n第1章　初识Linux shell	2\n1.1　什么是Linux	2\n1.1.1　深入探究Linux内核	3\n1.1.2　GNU工具链	10\n1.1.3　Linux桌面环境	11\n1.2　Linux发行版	16\n1.2.1　核心Linux发行版	16\n1.2.2　专业Linux发行版	17\n1.2.3　Linux LiveCD	17\n1.3　小结	19\n第2章　走进shell	20\n2.1　终端模拟	20\n2.1.1　图形功能	21\n2.1.2　键盘	24\n2.2　terminfo数据库	25\n2.3　Linux控制台	28\n2.4　xterm终端	29\n2.4.1　命令行参数	30\n2.4.2　xterm主菜单	31\n2.4.3　VT选项菜单	32\n2.4.4　VT字体菜单	34\n2.5　Konsole终端	36\n2.5.1　命令行参数	36\n2.5.2　标签式窗口会话	37\n2.5.3　配置文件	38\n2.5.4　菜单栏	39\n2.6　GNOME Terminal	43\n2.6.1　命令行参数	43\n2.6.2　标签	43\n2.6.3　菜单栏	44\n2.7　小结	47\n第3章　基本的bash shell命令	48\n3.1　启动shell	48\n3.2　shell提示符	49\n3.3　bash手册	51\n3.4　浏览文件系统	52\n3.4.1　Linux文件系统	52\n3.4.2　遍历目录	54\n3.5　文件和目录列表	56\n3.5.1　基本列表功能	56\n3.5.2　修改输出信息	57\n3.5.3　完整的参数列表	58\n3.5.4　过滤输出列表	60\n3.6　处理文件	61\n3.6.1　创建文件	61\n3.6.2　复制文件	61\n3.6.3　链接文件	63\n3.6.4　重命名文件	65\n3.6.5　删除文件	65\n3.7　处理目录	67\n3.7.1　创建目录	67\n3.7.2　删除目录	67\n3.8　查看文件内容	68\n3.8.1　查看文件统计信息	68\n3.8.2　查看文件类型	69\n3.8.3　查看整个文件	69\n3.8.4　查看部分文件	72\n3.9　小结	73\n第4章　更多的bash shell命令	75\n4.1　监测程序	75\n4.1.1　探查进程	75\n4.1.2　实时监测进程	82\n4.1.3　结束进程	84\n4.2　监测磁盘空间	85\n4.2.1　挂载存储媒体	86\n4.2.2　使用df命令	89\n4.2.3　使用du命令	89\n4.3　处理数据文件	90\n4.3.1　排序数据	91\n4.3.2　搜索数据	94\n4.3.3　压缩数据	96\n4.3.4　归档数据	99\n4.4　小结	100\n第5章　使用Linux环境变量	101\n5.1　什么是环境变量	101\n5.1.1　全局环境变量	102\n5.1.2　局部环境变量	103\n5.2　设置环境变量	106\n5.2.1　设置局部环境变量	106\n5.2.2　设置全局环境变量	107\n5.3　删除环境变量	107\n5.4　默认shell环境变量	108\n5.5　设置PATH环境变量	111\n5.6　定位系统环境变量	112\n5.6.1　登录shell	112\n5.6.2　交互式shell	116\n5.6.3　非交互式shell	118\n5.7　可变数组	118\n5.8　使用命令别名	119\n5.9　小结	120\n第6章　理解Linux文件权限	122\n6.1　Linux的安全性	122\n6.1.1　/etc/passwd文件	122\n6.1.2　/etc/shadow文件	124\n6.1.3　添加新用户	125\n6.1.4　删除用户	127\n6.1.5　修改用户	128\n6.2　使用Linux组	130\n6.2.1　/etc/group文件	131\n6.2.2　创建新组	131\n6.2.3　修改组	132\n6.3　理解文件权限	133\n6.3.1　使用文件权限符	133\n6.3.2　默认文件权限	134\n6.4　改变安全性设置	136\n6.4.1　改变权限	136\n6.4.2　改变所属关系	137\n6.5　共享文件	138\n6.6　小结	139\n第7章　管理文件系统	141\n7.1　探索Linux文件系统	141\n7.1.1　基本的Linux文件系统	141\n7.1.2　日志文件系统	142\n7.1.3　扩展的Linux日志文件系统	143\n7.2　操作文件系统	145\n7.2.1　创建分区	145\n7.2.2　创建文件系统	147\n7.2.3　如果出错了	149\n7.3　逻辑卷管理器	150\n7.3.1　逻辑卷管理布局	150\n7.3.2　Linux中的LVM	151\n7.3.3　使用Linux LVM	153\n7.4　小结	157\n第8章　安装软件程序	158\n8.1　包管理基础	158\n8.2　基于Debian的系统	159\n8.2.1　用aptitude管理软件包	159\n8.2.2　用aptitude安装软件包	161\n8.2.3　用aptitude更新软件	163\n8.2.4　用aptitude卸载软件	164\n8.2.5　aptitude库	164\n8.3　基于Red Hat的系统	166\n8.3.1　列出已安装包	166\n8.3.2　用yum安装软件	167\n8.3.3　用yum更新软件	168\n8.3.4　用yum卸载软件	169\n8.3.5　处理损坏的包依赖关系	169\n8.3.6　yum软件库	171\n8.4　从源码安装	172\n8.5　小结	174\n第9章　使用编辑器	176\n9.1　Vim编辑器	176\n9.1.1　Vim基础	176\n9.1.2　编辑数据	178\n9.1.3　复制和粘贴	179\n9.1.4　查找和替换	180\n9.2　Emacs编辑器	180\n9.2.1　在控制台上使用Emacs	180\n9.2.2　在X Window中使用Emacs	185\n9.3　KDE系编辑器	186\n9.3.1　KWrite编辑器	186\n9.3.2　Kate编辑器	190\n9.4　GNOME编辑器	192\n9.4.1　启动gedit	192\n9.4.2　基本的gedit功能	193\n9.4.3　设定偏好设置	194\n9.5　小结	196\n第二部分　shell脚本编程基础\n第10章　构建基本脚本	200\n10.1　使用多个命令	200\n10.2　创建shell脚本文件	201\n10.3　显示消息	202\n10.4　使用变量	203\n10.4.1　环境变量	204\n10.4.2　用户变量	205\n10.4.3　反引号	206\n10.5　重定向输入和输出	207\n10.5.1　输出重定向	208\n10.5.2　输入重定向	208\n10.6　管道	209\n10.7　执行数学运算	212\n10.7.1　expr命令	212\n10.7.2　使用方括号	214\n10.7.3　浮点解决方案	215\n10.8　退出脚本	218\n10.8.1　查看退出状态码	218\n10.8.2　exit命令	219\n10.9　小结	221\n第11章　使用结构化命令	222\n11.1　使用if-then语句	222\n11.2　if-then-else语句	224\n11.3　嵌套if	225\n11.4　test命令	226\n11.4.1　数值比较	227\n11.4.2　字符串比较	228\n11.4.3　文件比较	232\n11.5　复合条件测试	239\n11.6　if-then的高级特性	240\n11.6.1　使用双尖括号	240\n11.6.2　使用双方括号	241\n11.7　case命令	242\n11.8　小结	243\n第12章　更多的结构化命令	245\n12.1　for命令	245\n12.1.1　读取列表中的值	246\n12.1.2　读取列表中的复杂值	247\n12.1.3　从变量读取列表	248\n12.1.4　从命令读取值	249\n12.1.5　更改字段分隔符	250\n12.1.6　用通配符读取目录	251\n12.2　C语言风格的for命令	253\n12.2.1　C语言的for命令	253\n12.2.2　使用多个变量	255\n12.3　while命令	255\n12.3.1　while的基本格式	255\n12.3.2　使用多个测试命令	256\n12.4　until命令	258\n12.5　嵌套循环	259\n12.6　循环处理文件数据	261\n12.7　控制循环	262\n12.7.1　break命令	262\n12.7.2　continue命令	265\n12.8　处理循环的输出	267\n12.9　小结	269\n第13章　处理用户输入	270\n13.1　命令行参数	270\n13.1.1　读取参数	270\n13.1.2　读取程序名	272\n13.1.3　测试参数	274\n13.2　特殊参数变量	274\n13.2.1　参数计数	274\n13.2.2　抓取所有的数据	276\n13.3　移动变量	277\n13.4　处理选项	278\n13.4.1　查找选项	279\n13.4.2　使用getopt命令	282\n13.4.3　使用更高级的getopts	284\n13.5　将选项标准化	286\n13.6　获得用户输入	287\n13.6.1　基本的读取	287\n13.6.2　超时	289\n13.6.3　隐藏方式读取	290\n13.6.4　从文件中读取	290\n13.7　小结	291\n第14章　呈现数据	293\n14.1　理解输入和输出	293\n14.1.1　标准文件描述符	293\n14.1.2　重定向错误	295\n14.2　在脚本中重定向输出	297\n14.2.1　临时重定向	297\n14.2.2　永久重定向	298\n14.3　在脚本中重定向输入	299\n14.4　创建自己的重定向	299\n14.4.1　创建输出文件描述符	300\n14.4.2　重定向文件描述符	300\n14.4.3　创建输入文件描述符	301\n14.4.4　创建读写文件描述符	302\n14.4.5　关闭文件描述符	303\n14.5　列出打开的文件描述符	304\n14.6　阻止命令输出	305\n14.7　创建临时文件	306\n14.7.1　创建本地临时文件	306\n14.7.2　在/tmp目录创建临时文件	308\n14.7.3　创建临时目录	308\n14.8　记录消息	309\n14.9　小结	310\n第15章　控制脚本	312\n15.1　处理信号	312\n15.1.1　重温Linux信号	312\n15.1.2　产生信号	313\n15.1.3　捕捉信号	314\n15.1.4　捕捉脚本的退出	315\n15.1.5　移除捕捉	316\n15.2　以后台模式运行脚本	317\n15.2.1　后台运行脚本	317\n15.2.2　运行多个后台作业	318\n15.2.3　退出终端	319\n15.3　在非控制台下运行脚本	319\n15.4　作业控制	320\n15.4.1　查看作业	320\n15.4.2　重启停止的作业	322\n15.5　调整谦让度	323\n15.5.1　nice命令	323\n15.5.2　renice命令	324\n15.6　定时运行作业	324\n15.6.1　用at命令来计划执行作业	325\n15.6.2　计划定期执行脚本	328\n15.7　启动时运行	330\n15.7.1　开机时运行脚本	330\n15.7.2　在新shell中启动	332\n15.8　小结	333\n第三部分　高级shell脚本编程\n第16章　创建函数	336\n16.1　基本的脚本函数	336\n16.1.1　创建函数	337\n16.1.2　使用函数	337\n16.2　返回值	339\n16.2.1　默认退出状态码	339\n16.2.2　使用return命令	340\n16.2.3　使用函数输出	341\n16.3　在函数中使用变量	342\n16.3.1　向函数传递参数	342\n16.3.2　在函数中处理变量	344\n16.4　数组变量和函数	346\n16.4.1　向函数传数组参数	346\n16.4.2　从函数返回数组	348\n16.5　函数递归	349\n16.6　创建库	350\n16.7　在命令行上使用函数	351\n16.7.1　在命令行上创建函数	352\n16.7.2　在.bashrc文件中定义函数	352\n16.8　小结	354\n第17章　图形化桌面上的脚本编程	355\n17.1　创建文本菜单	355\n17.1.1　创建菜单布局	356\n17.1.2　创建菜单函数	356\n17.1.3　添加菜单逻辑	357\n17.1.4　整合shell脚本菜单	358\n17.1.5　使用select命令	359\n17.2　使用窗口	360\n17.2.1　dialog包	361\n17.2.2　dialog选项	366\n17.2.3　在脚本中使用dialog命令	368\n17.3　使用图形	369\n17.3.1　KDE环境	369\n17.3.2　GNOME环境	372\n17.4　小结	376\n第18章　初识sed和gawk	377\n18.1　文本处理	377\n18.1.1　sed编辑器	377\n18.1.2　gawk程序	380\n18.2　sed编辑器基础	385\n18.2.1　更多的替换选项	385\n18.2.2　使用地址	387\n18.2.3　删除行	389\n18.2.4　插入和附加文本	391\n18.2.5　修改行	392\n18.2.6　转换命令	393\n18.2.7　回顾打印	394\n18.2.8　用sed和文件一起工作	396\n18.3　小结	398\n第19章　正则表达式	399\n19.1　什么是正则表达式	399\n19.1.1　定义	399\n19.1.2　正则表达式的类型	400\n19.2　定义BRE模式	401\n19.2.1　纯文本	401\n19.2.2　特殊字符	402\n19.2.3　锚字符	403\n19.2.4　点字符	405\n19.2.5　字符组	405\n19.2.6　排除字符组	407\n19.2.7　使用区间	408\n19.2.8　特殊字符组	409\n19.2.9　星号	409\n19.3　扩展正则表达式	411\n19.3.1　问号	411\n19.3.2　加号	412\n19.3.3　使用花括号	412\n19.3.4　管道符号	413\n19.3.5　聚合表达式	414\n19.4　实用中的正则表达式	414\n19.4.1　目录文件计数	415\n19.4.2　验证电话号码	416\n19.4.3　解析邮件地址	417\n19.5　小结	419\n第20章　sed进阶	420\n20.1　多行命令	420\n20.1.1　next命令	421\n20.1.2　多行删除命令	424\n20.1.3　多行打印命令	424\n20.2　保持空间	425\n20.3　排除命令	426\n20.4　改变流	428\n20.4.1　跳转	429\n20.4.2　测试	430\n20.5　模式替代	431\n20.5.1　and符号	431\n20.5.2　替换单独的单词	432\n20.6　在脚本中使用sed	433\n20.6.1　使用包装脚本	433\n20.6.2　重定向sed的输出	434\n20.7　创建sed实用工具	434\n20.7.1　加倍行间距	434\n20.7.2　对可能含有空白行的文件加倍行间距	435\n20.7.3　给文件中的行编号	436\n20.7.4　打印末尾行	437\n20.7.5　删除行	437\n20.7.6　删除HTML标签	439\n20.8　小结	441\n第21章　gawk进阶	442\n21.1　使用变量	442\n21.1.1　内建变量	442\n21.1.2　自定义变量	447\n21.2　处理数组	449\n21.2.1　定义数组变量	449\n21.2.2　遍历数组变量	450\n21.2.3　删除数组变量	451\n21.3　使用模式	451\n21.3.1　正则表达式	451\n21.3.2　匹配操作符	452\n21.3.3　数学表达式	452\n21.4　结构化命令	453\n21.4.1　if语句	453\n21.4.2　while语句	455\n21.4.3　do-while语句	456\n21.4.4　for语句	457\n21.5　格式化打印	457\n21.6　内建函数	460\n21.6.1　数学函数	460\n21.6.2　字符串函数	461\n21.6.3　时间函数	463\n21.7　自定义函数	463\n21.7.1　定义函数	463\n21.7.2　使用自定义函数	464\n21.7.3　创建函数库	464\n21.8　小结	465\n第22章　使用其他shell	467\n22.1　什么是dash shell	467\n22.2　dash shell的特性	468\n22.2.1　dash命令行参数	468\n22.2.2　dash环境变量	469\n22.2.3　dash内建命令	471\n22.3　dash脚本编程	472\n22.3.1　创建dash脚本	473\n22.3.2　不能使用的功能	473\n22.4　zsh shell	477\n22.5　zsh shell的组成	478\n22.5.1　shell选项	478\n22.5.2　内建命令	480\n22.6　zsh脚本编程	485\n22.6.1　数学运算	485\n22.6.2　结构化命令	487\n22.6.3　函数	487\n22.7　小结	489\n第四部分　高级shell脚本编程主题\n第23章　使用数据库	492\n23.1　MySQL数据库	492\n23.1.1　安装MySQL	492\n23.1.2　MySQL客户端界面	494\n23.1.3　创建MySQL数据库对象	498\n23.2　PostgreSQL数据库	500\n23.2.1　安装PostgreSQL	501\n23.2.2　PostgreSQL命令行界面	501\n23.2.3　创建PostgreSQL数据库对象	503\n23.3　使用数据表	505\n23.3.1　创建数据表	505\n23.3.2　插入和删除数据	507\n23.3.3　查询数据	508\n23.4　在脚本中使用数据库	509\n23.4.1　连接到数据库	509\n23.4.2　向服务器发送命令	511\n23.4.3　格式化数据	514\n23.5　小结	516\n第24章　使用Web	517\n24.1　Lynx程序	517\n24.1.1　安装Lynx	518\n24.1.2　lynx命令行	518\n24.1.3　Lynx配置文件	523\n24.1.4　Lynx环境变量	524\n24.1.5　从Lynx中抓取数据	524\n24.2　cURL程序	527\n24.2.1　安装cURL	527\n24.2.2　探索cURL	527\n24.3　使用zsh处理网络	528\n24.3.1　TCP模块	528\n24.3.2　客户端/服务器模式	529\n24.3.3　使用zsh进行C/S编程	530\n24.4　小结	533\n第25章　使用E-mail	534\n25.1　Linux E-mail基础	534\n25.1.1　Linux中的E-mail	534\n25.1.2　邮件传送代理	535\n25.1.3　邮件投递代理	536\n25.1.4　邮件用户代理	537\n25.2　建立服务器	540\n25.2.1　sendmail	541\n25.2.2　Postfix	543\n25.3　使用Mailx发送消息	545\n25.4　Mutt程序	548\n25.4.1　安装Mutt	548\n25.4.2　Mutt命令行	548\n25.4.3　使用Mutt	549\n25.5　小结	551\n第26章　编写脚本实用工具	552\n26.1　监测磁盘空间	552\n26.1.1　需要的功能	552\n26.1.2　创建脚本	555\n26.1.3　运行脚本	556\n26.2　进行备份	557\n26.3　管理用户账户	563\n26.3.1　需要的功能	563\n26.3.2　创建脚本	569\n26.4　小结	575\n第27章　shell脚本编程进阶	576\n27.1　监测系统统计数据	576\n27.1.1　系统快照报告	576\n27.1.2　系统统计数据报告	582\n27.2　问题跟踪数据库	589\n27.2.1　创建数据库	589\n27.2.2　记录问题	591\n27.2.3　更新问题	594\n27.2.4　查找问题	599\n27.3　小结	602\n附录A　bash命令快速指南	604\n附录B　sed和gawk快速指南	611\n', '9787115288899', '{\"small\":\"https://img3.doubanio.com/spic/s11171426.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s11171426.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s11171426.jpg\"}', 'undefined', '1', '[{\"count\":265,\"name\":\"Linux\",\"title\":\"Linux\"},{\"count\":235,\"name\":\"shell\",\"title\":\"shell\"},{\"count\":89,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":75,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":50,\"name\":\"linux\",\"title\":\"linux\"},{\"count\":35,\"name\":\"Shell\",\"title\":\"Shell\"},{\"count\":32,\"name\":\"操作系统\",\"title\":\"操作系统\"},{\"count\":32,\"name\":\"Linux/Unix\",\"title\":\"Linux/Unix\"}]');
INSERT INTO `book` VALUES ('124', '7111338294', 'Linux内核设计与实现(原书第3版)', 'Linux Kernel Development, 3E', '', 'https://api.douban.com/v2/book/6097773', 'https://book.douban.com/subject/6097773/', 'https://img1.doubanio.com/mpic/s6387169.jpg', 'Robert Love', '陈莉君,康华', '机械工业出版社华章公司', '2011-4-30', '平装', '69.00元', '352', 'Robert Love 是一位资深的开源社区达人，很早就开始使用Linux。目前他是Google公司高级软件工程师，是开发Android移动平台内核的团队成员；他曾在Novell公司任职Linux桌面系统的首席架构师；他之前也曾是MontaVista和Ximain公司的内核开发工程师。他参与的内核项目包括抢占式内核、进程调度器、内核事件层、通知机制、VM改进，以及设备驱动程序。他是《Linux journal》杂志的编辑。另外他还著有《Linux System Programming》和《Linux in a Nutshell》。', '《Linux内核设计与实现(原书第3版)》详细描述了Linux内核的设计与实现。内核代码的编写者、开发者以及程序开发人员都可以通过阅读本书受益，他们可以更好理解操作系统原理，并将其应用在自己的编码中以提高效率和生产率。\n《Linux内核设计与实现(原书第3版)》详细描述了Linux内核的主要子系统和特点，包括Linux内核的设计、实现和接口。从理论到实践涵盖了Linux内核的方方面面，可以满足读者的各种兴趣和需求。\n作者Robert Love是一位Linux内核核心开发人员，他分享了在开发Linux 2.6内核过程中颇具价值的知识和经验。本书的主题包括进程管理、进程调度、时间管理和定时器、系统调用接口、内存寻址、内存管理和页缓存、VFS、内核同步、移植性相关的问题以及调试技术。同时本书也涵盖了Linux 2.6内核中颇具特色的内容，包括CFS调度程序、抢占式内核、块I/O层以及I/O调度程序。\n《Linux内核设计与实现(原书第3版)》新增内容包括：\n增加一章专门描述内核数据结构\n详细描述中断处理程序和下半部机制\n扩充虚拟内存和内存分配的内容\n调试Linux内核的技巧\n内核同步和锁机制的深度描述\n提交内核补丁以及参与Linux内核社区的建设性建议', '译者序\n序言\n前言\n作者简介\n第1章　Linux内核简介\n1.1　Unix的历史\n1.2　追寻Linus足迹：Linux简介\n1.3　操作系统和内核简介\n1.4　Linux内核和传统Unix内核的比较\n1.5　Linux内核版本\n1.6　Linux内核开发者社区\n1.7　小结\n第2章　从内核出发\n第3章　进程管理\n第4章　进程调度\n第5章　系统调用\n第6章　内核数据结构\n第7章　中断和中断处理\n第8章　下半部和推后执行的工作\n第9章　内核同步介绍\n第10章　内核同步方法\n第11章　定时器和时间管理\n第12章　内存管理\n第13章　虚拟文件系统\n第14章　块I/O层\n第15章　进程地址空间\n第16章　页高速缓存和页回写\n第17章　设备与模块\n第18章　调试\n第19章　可移植性\n第20章　补丁、开发和社区参考资料', '9787111338291', '{\"small\":\"https://img1.doubanio.com/spic/s6387169.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s6387169.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s6387169.jpg\"}', 'undefined', '1', '[{\"count\":362,\"name\":\"Linux\",\"title\":\"Linux\"},{\"count\":233,\"name\":\"kernel\",\"title\":\"kernel\"},{\"count\":175,\"name\":\"操作系统\",\"title\":\"操作系统\"},{\"count\":126,\"name\":\"内核\",\"title\":\"内核\"},{\"count\":76,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":45,\"name\":\"linux\",\"title\":\"linux\"},{\"count\":31,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":30,\"name\":\"Linux/Unix\",\"title\":\"Linux/Unix\"}]');
INSERT INTO `book` VALUES ('125', '7115337969', 'Node学习指南', '', '', 'https://api.douban.com/v2/book/25843153', 'https://book.douban.com/subject/25843153/', 'https://img1.doubanio.com/mpic/s27234937.jpg', 'Shelley Powers', '夏思雨,高亮', '人民邮电出版社', '2014-3', '', '69.00', '', 'shelley powers从javascript刚发布时，就开始使用和编写web技术相关书籍。她之前在o’reilly出版了8本书，包括developing asp components（2001），adding ajax（2007）和javascript cookbook（2010）。', 'node.js是一套用来编写高性能网络服务器的javascript工具包。它可以让javascript在服务器端运行，因此，可用来快速构建网络服务及应用的平台。\n《node学习指南》是学习node编程的入门指南。全书共16章。前4章主要介绍node基本知识，包管理工具(npm)的安装和使用等。第5章介绍了node处理异步开发的独特的实现方式等。第6~8章，讲解了路由、代理、web服务器、中间件等基本概念，包括express。第9章到第11章分别介绍了基于redis、mongodb以及关系型数据库的node应用开发。第12章到第14章分别介绍了图形和媒体、sockets.io模块、调试和测试等主题。第15章介绍了安全和权限的问题，第16章介绍了node应用的扩展和部署。\n《node学习指南》适合有一定基础的javascript程序员阅读，也适合对学习node应用开发感兴趣的读者学习参考。', '《node学习指南》\n第1章　node.js：启动与运行　1\n1.1　搭建node开发环境　2\n1.1.1　linux(ubuntu)下安装node　2\n1.1.2　windows 7平台下node+webmatrix　4\n1.1.3　升级node　8\n1.2　开始node开发　9\n1.2.1　hello, world in node　9\n1.2.2　分析“hello,world”　11\n1.3　异步函数及node事件循环　13\n1.3.1　使用异步方式读取文件　14\n1.3.2　观察异步程序流程　15\n1.4　node的优势　19\n第2章　node与repl　20\n2.1　repl：先睹为快和未定义的表达式　20\n2.2　repl的优势：更好地理解表层之下的javascript　22\n2.3　多行以及更复杂的javascript　23\n2.3.1　repl命令　26\n2.3.2　repl和rlwrap　27\n2.3.3　定制repl　28\n.2.4　不可预计的意外——记得经常保存　32\n第3章　node核心库　33\n3.1　全局对象：global、process和buffer　34\n3.1.1　global　34\n3.1.2　process　36\n3.1.3　buffer　38\n3.2　定时器：settimeout、cleartimeout、setinterval 和clearinterval　39\n3.3　servers、streams和sockets　40\n3.3.1　tcp sockets和servers　41\n3.3.2　http　43\n3.3.3　udp数据报套接字　45\n3.3.4　流、管道和readline　47\n3.4　子进程　49\n3.4.1　child_process.spawn　50\n3.4.2　child_process.exec和child_process.execfile　52\n3.4.3　child_process.fork　52\n3.4.4　在windows系统中使用子进程　53\n3.5　域名解析和url处理　54\n3.6　utilities模块和对象继承　55\n3.7　events和eventemitter　59\n第4章　node模块系统　63\n4.1　使用require和默认路径加载模块　63\n4.2　外部模块和node包管理工具　65\n4.3　如何找到你需要的模块　69\n4.3.1　colors：简单至上　71\n4.3.2　optimist：另一个简单的小模块　73\n4.3.3　underscore　74\n4.4　创建自定义模块　75\n4.4.1　打包整个目录　76\n4.4.2　为你的模块发布做准备　76\n4.4.3　发布模块　80\n第5章　控制流、异步模式和异常处理　82\n5.1　使用callback而不使用promises　82\n5.2　顺序调用、嵌套回调、异常捕获　85\n5.3　异步模式和控制流模块　92\n5.3.1　step　93\n5.3.2　async　96\n5.4　node编码风格　101\n第6章　路由寻址、服务文件和中间件　103\n6.1　从头开始：创建一个简单的静态文件服务器　103\n6.2　中间件　110\n6.2.1　connect基本知识　111\n6.2.2　connect中间件　113\n6.2.3　定制connect中间件　118\n6.3　routers　121\n6.4　proxies　124\n第7章　express框架　128\n7.1　express：启动和运行　129\n7.2　app.js文件　130\n7.3　错误处理　133\n7.4　express与connect的关系　134\n7.5　路由　135\n7.5.1　路由路径　137\n7.5.2　路由和http动词　140\n7.6　关于mvc　147\n7.7　使用curl测试express应用程序　152\n第8章　express、模板系统和css　154\n8.1　ejs模板系统(embedded javascript template system)　154\n8.1.1　基本语法　155\n8.1.2　node与ejs　156\n8.1.3　ejs与node filters　158\n8.2　在express中使用ejs　159\n8.2.1　多对象环境的改造　161\n8.2.2　静态文件路由　162\n8.2.3　处理一个新对象的post请求　164\n8.2.4　widget索引和生成picklist　166\n8.2.5　显示单个对象并确认对象的删除操作　168\n8.2.6　提供更新信息的表达以及处理put请求　170\n8.3　jade模板系统　173\n8.3.1　jade语法简介　173\n8.3.2　使用block和extends模块化视图模板　176\n8.3.3　widget view转换为jade模板　178\n8.3.4　转换edit和delete表单　179\n8.4　使用stylus完成简单的css样式　182\n第9章　结构化数据、noe和redis　187\n9.1　node和redis　188\n9.2　构建游戏得分排行榜　190\n9.3　创建消息队列　197\n9.4　为express应用程序添加统计中间件　201\n第10章　node和mongodb：文档中心数据　206\n10.1　mongodb native node.js driver(mongodb原生node.js驱动)　207\n10.1.1　mongodb入门　207\n10.1.2　定义、创建以及销毁mongodb collection　208\n10.1.3　为collection添加数据　209\n10.1.4　查询数据　212\n10.1.5　使用updates、upserts、find和remove　216\n10.2　使用mongoose实现widget模块　221\n10.3 重构widget工厂　222\n10.4　添加mongodb后台　223\n第11章　node与关系型数据库　228\n11.1　db-mysql入门　229\n11.1.1　查询字符串和方法链　229\n11.1.2　使用查询字符串更新数据库　233\n11.1.3　使用方法链更新数据库　235\n11.2　使用node-mysql实现本地mysql访问　237\n11.2.1　使用node-mysql做基本的crud操作　237\n11.2.2　mysql事务与mysql-queues　239\n11.3　orm与sequelize　241\n11.3.1　定义模型　241\n11.3.2　orm风格的crud实现　243\n11.3.3　添加多个对象　246\n11.3.4　从关系型到orm　247\n第12章　图形和html5 video　248\n12.1　创建和使用pdf　248\n12.1.1　使用子进程访问pdf工具　249\n12.1.2　使用pdfkit创建pdf　257\n12.2　从子进程访问imagemagick　258\n12.3　通过http提供html5 video服务　263\n12.4　创建和流化画布内容(canvas content)　267\n第13章　websockets和socket.io　271\n13.1　websockets　271\n13.2　socket.io简介　272\n13.2.1　一个简单的通信范例　273\n13.2.2　异步世界里的websockets　276\n13.2.3　关于客户端代码　277\n13.3　配置socket.io　278\n13.4　chat：websockets版本的“hello, world”　279\n13.5　在express中使用socket.io　282\n第14章　node应用程序的测试和调试　284\n14.1　调试　284\n14.1.1　node.js debugger　284\n14.1.2　使用node inspector的客户端调试　287\n14.2　单元测试(unit testing)　289\n14.2.1　assert与单元测试　289\n14.2.2　nodeunit与单元测试　293\n14.2.3　其他测试框架　295\n14.3　验收测试　299\n14.3.1　soda和selenium测试　299\n14.3.2　通过tobi和zombie模拟浏览器　303\n14.4　性能测试：基准问题和负载测试　304\n14.4.1　apachebench基准测试　305\n14.4.2　nodeload与负载测试　309\n14.5　nodemon更新代码　312\n第15章　安全及防护　313\n15.1　数据加密　314\n15.1.1　tsl/ssl配置　314\n15.1.2　使用https　315\n15.1.3　如何安全的保存密码　317\n15.2　认证/授权及passport　320\n15.2.1　授权/认证策略：oauth、openid、用户名/密码验证　321\n15.2.2　local passport strategy　323\n15.2.3　twitter passport strategy(oauth)　330\n15.3　保护应用程序，防止攻击　336\n15.3.1　不要使用eval　336\n15.3.2　尽量使用复选框、单选按钮和下拉式选项　337\n15.3.3　使用node-validator　337\n15.4　在沙箱中执行代码　339\n第16章　扩展和部署node应用　343\n16.1　把你的节点部署到服务器上　343\n16.1.1　编写package.json文件　344\n16.1.2　使用forever让你的应用“永不掉线”　347\n16.1.3　使用node和apache　350\n16.1.4　改善性能　352\n16.2　部署到云服务　352\n16.2.1　通过cloud9 ide部署到windows azure　353\n16.2.2　joyent development smartmachine　355\n16.2.3　heroku　355\n16.2.4　amazon ec2　356\n16.2.5　nodejitsu　356\n附录　node、git和github　357', '9787115337962', '{\"small\":\"https://img1.doubanio.com/spic/s27234937.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s27234937.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s27234937.jpg\"}', 'undefined', '1', '[{\"count\":17,\"name\":\"NodeJS\",\"title\":\"NodeJS\"},{\"count\":12,\"name\":\"JavaScript\",\"title\":\"JavaScript\"},{\"count\":10,\"name\":\"Node.js\",\"title\":\"Node.js\"},{\"count\":6,\"name\":\"前端\",\"title\":\"前端\"},{\"count\":5,\"name\":\"programming\",\"title\":\"programming\"},{\"count\":4,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":4,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":3,\"name\":\"node.js\",\"title\":\"node.js\"}]');
INSERT INTO `book` VALUES ('127', '7111506944', 'JavaScript应用程序设计', 'Programming JavaScript Applications', '使用Node、HTML5和现代JavaScript类库打造稳健的web应用', 'https://api.douban.com/v2/book/26675852', 'https://book.douban.com/subject/26675852/', 'https://img3.doubanio.com/mpic/s28352070.jpg', 'Eric Elliott', '吴斌', '机械工业出版社', '2015-9-25', '平装', 'CNY 59.00', '219', 'Eric Elliott是一位经验丰富的JavaScript应用程序开发者，他曾在Adobe Creative Cloud团队中担任科学家，在Tout公司(一家视频分享网站)担任首席JavaScript工程师，在Zumba Fitness公司(全球领先的健身品牌)担任首席客户端应用架构师，同时他还是作家、演讲者、用户体验与营销领域的顾问。', '', '目录\n前言 1\n第1章 JavaScript的革命时代 7\nJavaScript的特性 8\n性能 8\n对象 8\n语法 9\n函数是一等公民 9\n事件 9\n复用性 10\n结论 10\n解构现代JavaScript应用 10\n基础架构 10\nJSON ——数据存储与通信 11\nNoSQL数据库 12\nRESTful JSON Web Services 12\n第2章 函数 15\n减少隐式副作用 16\n函数声明 18\nlambdas 22\n立即执行函数表达式 23\n方法上下文 25\n函数作用域 27\n变量提升 28\n闭包 30\n方法API的设计 33\n参数命名 33\n多态函数 34\n范型编程与集合多态 37\n链式调用与流式API 40\n函数式编程 41\n无状态函数(纯函数) 43\n偏函数应用与函数加里化 44\n异步操作 45\n回调函数 46\nPromises与Deferreds 46\n小结 49\n第3章 对象 50\n过时的类继承 51\n流式JavaScript 53\n原型 56\n原型代理 56\n原型克隆 58\n享元模式 60\n创建对象 61\n工厂函数 63\n使用Stamps进行原型继承 66\n小结 71\n第4章 模块 73\n模块化编程原则 74\n接口 75\n模块模式 79\nAMD规范 81\n加载器插件 82\nCommonJS模块规范 84\nnpm包管理器 85\nES6模块规范 87\n基于CommonJS、npm、Grunt与Browserify构建客户端应用 89\n定义应用 89\n特性实现 91\n构建与部署 94\n小结 98\n第5章 关注点分离 99\n客户端的关注点 100\n模块管理 101\n模型－视图－控制器 113\n表现层与Dom操作 116\n服务端关注点 123\nNode与Express入门 124\n在Node中组织代码 125\n小结 132\n第6章 访问控制 134\n身份验证 134\n密码认证 134\nCredential类库 138\n多因素身份验证 140\n联合认证与授权认证 142\n应用功能授权 144\n应用授权 144\nOAuth 2.0协议 145\n小结 146\n第7章 日志 147\n调试 147\n服务端数据监控 149\n安全/入侵检测 149\n审计 150\n业务指标分析 150\n传播力度 151\n日志清单 151\n应用请求日志 152\n异常日志 156\n日志输出示例 158\n日志预警 161\n跟踪业务指标（效果跟踪） 162\n性能分析与优化 162\n客户端事件记录 163\n日志数据挖掘 164\n小结 165\n第8章 构建RESTful API 166\n可用性 167\n专一性 167\n一致性 169\n自描述的超媒体 177\n功能可见性 177\n超媒体即应用状态引擎 178\nHTML：一种特别的API媒介类型 180\nJade 180\nJiron 182\n响应式API 184\n性能优化 186\n小结 187\n第9章 特性开关 188\n组织特性 188\n特性的规模 188\n特性编组 189\n特性的生命周期 189\n开发阶段 190\n预发布阶段 190\n灰度测试 190\n正式发布 190\n默认激活 191\n完整集成 191\n客户端实现 191\n小结 195\n第10章 应用工程国际化 196\n小结 198\n附录A JavaScript编码风格指南 199', '9787111506942', '{\"small\":\"https://img3.doubanio.com/spic/s28352070.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s28352070.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s28352070.jpg\"}', 'undefined', '0', '[{\"count\":5,\"name\":\"JavaScript\",\"title\":\"JavaScript\"},{\"count\":2,\"name\":\"Web前端\",\"title\":\"Web前端\"},{\"count\":2,\"name\":\"Web工程与设计\",\"title\":\"Web工程与设计\"},{\"count\":2,\"name\":\"前端\",\"title\":\"前端\"}]');
INSERT INTO `book` VALUES ('128', '7115352461', 'Node.js实战', 'Node.js in Action', '', 'https://api.douban.com/v2/book/25870705', 'https://book.douban.com/subject/25870705/', 'https://img3.doubanio.com/mpic/s27264241.jpg', '', '[美] Mike Cantelon,[美] TJ Holowaychuk,[美] Nathan Rajlich', '人民邮电出版社', '2014-5', '平装', '69.00元', '356', '作者简介：\nMike Cantelon\nNode.js核心框架贡献者、Node社区活跃分子、资深培训师和演讲人。\nMarc Harter\nNode.js核心框架贡献者。\nT.J. Holowaychuk\n参与开发了很多Node.js模块，包括流行的Express框架。\nNathan Rajlich\n大名鼎鼎的TooTallNate，Node.js核心代码提交者。\n译者简介：\n吴海星\n2001年毕业于南京理工大学。编程数载代码不过几十万，翻译几年码字不过几百万。项目不过十几个，带队不到五十人。年过而立，惴惴不安，愈加发奋，孜孜求学，愿凭绵薄之力，贡献于IT社区。', '服务器端JavaScript？没错。Node.js是一个JavaScript服务器，支持可伸缩的高性能Web应用。借助异步I/O，这个服务器可以同时做很多事情，能满足聊天、游戏和实时统计等应用的需求。并且既然是JavaScript，那你就可以全栈使用一种语言。\n本书向读者展示了如何构建产品级应用，对关键概念的介绍清晰明了，贴近实际的例子，涵盖从安装到部署的各个环节，是一部讲解与实践并重的优秀著作。通过学习本书，读者将深入异步编程、数据存储、输出模板、读写文件系统，掌握创建TCP/IP服务器和命令行工具等非HTTP程序的技术。本书同样非常适合熟悉Rails、Django或PHP开发的读者阅读学习。\n本书主要内容：\nNode.js及其扩展的安装配置；\n全面理解异步编程和事件循环；\n学会开发微博、聊天和游戏等热门应用。', '第一部分　Node基础\n第1章　欢迎进入Node.js世界　　2\n1.1　构建于JavaScript之上　　3\n1.2　异步和事件触发：浏览器　　4\n1.3　异步和事件触发：服务器　　5\n1.4　DIRT程序　　6\n1.5　默认DIRT　　8\n1.5.1　简单的异步程序　　9\n1.5.2　Hello World HTTP服务器　　10\n1.5.3　流数据　　10\n1.6　小结　　11\n第2章　构建有多个房间的聊天室程序　　12\n2.1　程序概览　　12\n2.2　程序需求及初始设置　　15\n2.2.1　提供HTTP和WebSocket服务　　15\n2.2.2　创建程序的文件结构　　16\n2.2.3　指明依赖项　　16\n2.2.4　安装依赖项　　17\n2.3　提供HTML、CSS和客户端JavaScript的服务　　18\n2.3.1　创建静态文件服务器　　19\n2.3.2　添加HTML和CSS文件　　21\n2.4　用Socket.IO处理与聊天相关的消息　　23\n2.4.1　设置Socket.IO服务器　　24\n2.4.2　处理程序场景及事件　　25\n2.5　在程序的用户界面上使用客户端JavaScript　　29\n2.5.1　将消息和昵称/房间变更请求传给服务器　　29\n2.5.2　在用户界面中显示消息及可用房间　　30\n2.6　小结　　34\n第3章　Node编程基础　　35\n3.1　Node功能的组织及重用　　36\n3.1.1　创建模块　　37\n3.1.2　用module.exports微调模块的创建　　39\n3.1.3　用node_modules重用模块　　40\n3.1.4　注意事项　　41\n3.2　异步编程技术　　42\n3.2.1　用回调处理一次性事件　　43\n3.2.2　用事件发射器处理重复性事件　　46\n3.2.3　异步开发的难题　　53\n3.3　异步逻辑的顺序化　　54\n3.3.1　什么时候使用串行流程控制　　55\n3.3.2　实现串行化流程控制　　56\n3.3.3　实现并行化流程控制　　58\n3.3.4　利用社区里的工具　　60\n3.4　小结　　61\n第二部分　用Node开发Web程序\n第4章　构建Node Web程序　　64\n4.1　HTTP服务器的基础知识　　64\n4.1.1　Node如何向开发者呈现HTTP请求　　65\n4.1.2　一个用“Hello World”做响应的HTTP服务器　　67\n4.1.3　读取请求头及设定响应头　　67\n4.1.4　设定HTTP响应的状态码　　67\n4.2　构建RESTful Web服务　　68\n4.2.1　用POST请求创建资源　　69\n4.2.2　用GET请求获取资源　　71\n4.2.3　用DELETE请求移除资源　　72\n4.3　提供静态文件服务　　73\n4.3.1　创建一个静态文件服务器　　73\n4.3.2　处理服务器错误　　77\n4.3.3　用fs.stat()实现先发制人的错误处理　　77\n4.4　从表单中接受用户输入　　78\n4.4.1　处理提交的表单域　　78\n4.4.2　用formidable处理上传的文件　　81\n4.4.3　计算上传进度　　84\n4.5　用HTTPS加强程序的安全性　　85\n4.6　小结　　86\n第5章　存储Node程序中的数据　　87\n5.1　无服务器的数据存储　　88\n5.1.1　内存存储　　88\n5.1.2　基于文件的存储　　88\n5.2　关系型数据库管理系统　　91\n5.2.1　MySQL　　91\n5.2.2　PostgreSQL　　99\n5.3　NoSQL数据库　　100\n5.3.1　Redis　　101\n5.3.2　MongoDB　　105\n5.3.3　Mongoose　　107\n5.4　小结　　109\n第6章　Connect　　110\n6.1　搭建一个Connect程序　　111\n6.2　Connect的工作机制　　112\n6.2.1　做日志的中间件　　112\n6.2.2　响应“hello world”的中间件　　113\n6.3　为什么中间件的顺序很重要　　114\n6.3.1　中间件什么时候不调用next()　　114\n6.3.2　用中间件的顺序执行认证　　115\n6.4　挂载中间件和服务器　　115\n6.4.1　认证中间件　　116\n6.4.2　显示管理面板的中间件　　117\n6.5　创建可配置中间件　　118\n6.5.1　创建可配置的logger中间件组件　　119\n6.5.2　构建路由中间件组件　　120\n6.5.3　构建一个重写URL的中间件组件　　122\n6.6　使用错误处理中间件　　123\n6.6.1　Connect的默认错误处理器　　124\n6.6.2　自行处理程序错误　　124\n6.6.3　使用多个错误处理中间件组件　　125\n6.7　小结　　129\n第7章　Connect自带的中间件　　130\n7.1　解析cookie、请求主体和查询字符串的中间件　　131\n7.1.1　cookieParser()：解析HTTP cookie　　131\n7.1.2　bodyParser()：解析请求主体　　134\n7.1.3　limit()：请求主体的限制　　135\n7.1.4　query()：查询字符串解析　　137\n7.2　实现Web程序核心功能的中间件　　138\n7.2.1　logger()：记录请求　　138\n7.2.2　favicon()：提供favicon　　140\n7.2.3　methodOverride()：伪造HTTP方法　　141\n7.2.4　vhost()：虚拟主机　　143\n7.2.5　session()：会话管理　　144\n7.3　处理Web程序安全的中间件　　148\n7.3.1　basicAuth()：HTTP基本认证　　148\n7.3.2　csrf()：跨站请求伪造防护　　150\n7.3.3　errorHandler()：开发错误处理　　150\n7.4　提供静态文件服务的中间件　　152\n7.4.1　static()：静态文件服务　　152\n7.4.2　compress()：压缩静态文件　　154\n7.4.3　directory()：目录列表　　156\n7.5　小结　　157\n第8章　Express　　158\n8.1　生成程序骨架　　160\n8.1.1　安装Express的可执行程序　　161\n8.1.2　生成程序　　162\n8.1.3　探索程序　　162\n8.2　配置Express和你的程序　　164\n8.3　渲染视图　　166\n8.3.1　视图系统配置　　167\n8.3.2　视图查找　　169\n8.3.3　把数据输出到视图中　　171\n8.4　处理表单和文件上传　　175\n8.4.1　实现照片模型　　175\n8.4.2　创建照片上传表单　　176\n8.4.3　显示上传照片列表　　178\n8.5　创建资源下载　　179\n8.5.1　创建照片下载路由　　179\n8.5.2　实现照片下载路由　　180\n8.6　小结　　182\n第9章　Express进阶　　183\n9.1　认证用户　　184\n9.1.1　保存和加载用户　　184\n9.1.2　注册新用户　　189\n9.1.3　已注册用户登录　　194\n9.1.4　用户加载中间件　　197\n9.2　先进的路由技术　　199\n9.2.1　校验用户内容提交　　199\n9.2.2　特定路由中间件　　202\n9.2.3　实现分页　　205\n9.3　创建一个公开的REST API　　208\n9.3.1　设计API　　208\n9.3.2　添加基本的认证　　209\n9.3.3　实现路由　　209\n9.3.4　启用内容协商　　212\n9.4　错误处理　　214\n9.4.1　处理404错误　　215\n9.4.2　处理错误　　217\n9.5　小结　　220\n第10章　测试Node程序　　221\n10.1　单元测试　　222\n10.1.1　assert模块　　222\n10.1.2　Nodeunit　　225\n10.1.3　Mocha　　227\n10.1.4　Vows　　232\n10.1.5　should.js　　234\n10.2　验收测试　　235\n10.2.1　Tobi　　236\n10.2.2　Soda　　237\n10.3　小结　　239\n第11章　Web程序模板　　240\n11.1　用模板保持代码的整洁性　　240\n11.2　嵌入JavaScript的模板　　244\n11.2.1　创建模板　　245\n11.2.2　用EJS过滤器处理模板数据　　246\n11.2.3　将EJS集成到你的程序中　　249\n11.2.4　在客户端程序中使用EJS　　250\n11.3　使用Mustache模板语言与Hogan　　251\n11.3.1　创建模板　　251\n11.3.2　Mustache标签　　252\n11.3.3　微调Hogan　　254\n11.4　用Jade做模板　　255\n11.4.1　Jade基础知识　　256\n11.4.2　Jade模板中的逻辑　　258\n11.4.3　组织Jade模板　　260\n11.5　小结　　264\n第三部分　在Node中更进一步\n第12章　部署Node程序并维持正常运行时间　　266\n12.1　安置Node程序　　266\n12.1.1　专用的和虚拟私有服务器　　267\n12.1.2　云主机　　268\n12.2　部署的基础知识　　269\n12.2.1　从Git存储库部署　　270\n12.2.2　让Node保持运行　　270\n12.3　让正常运行时间和性能达到最优　　271\n12.3.1　用Upstart维护正常运行时间　　272\n12.3.2　集群API：利用多核的优势　　273\n12.3.3　静态文件及代理　　275\n12.4　小结　　277\n第13章　超越Web服务器　　278\n13.1　Socket.IO　　278\n13.1.1　创建一个最小的Socket.IO程序　　279\n13.1.2　用Socket.IO触发页面和CSS的重新加载　　281\n13.1.3　Socket.IO的其他用法　　283\n13.2　深入TCP/IP网络　　284\n13.2.1　处理缓冲区和二进制数据　　284\n13.2.2　创建TCP服务器　　286\n13.2.3　创建TCP客户端　　289\n13.3　跟操作系统交互的工具　　290\n13.3.1　单例的全局process对象　　291\n13.3.2　使用文件系统模块　　293\n13.3.3　繁衍外部进程　　296\n13.4　开发命令行工具　　301\n13.4.1　解析命令行参数　　301\n13.4.2　处理stdin和stdout　　302\n13.4.3　添加彩色的输出　　304\n13.5　小结　　306\n第14章　Node生态系统　　307\n14.1　给Node开发人员的在线资源　　308\n14.1.1　Node和模块的参考资料　　308\n14.1.2　Google群组　　309\n14.1.3　IRC　　309\n14.1.4　GitHub问题列表　　310\n14.2　GitHub　　310\n14.2.1　GitHub入门　　311\n14.2.2　添加一个项目到GitHub中　　312\n14.2.3　用GitHub协作　　314\n14.3　为npm库做贡献　　316\n14.3.1　准备包　　317\n14.3.2　编写包规范　　317\n14.3.3　测试和发布包　　318\n14.4　小结　　320\n附录A　安装Node和社区附加组件　　321\n附录B　调试Node　　329\n附录C　Express的扩展及配置　　336', '9787115352460', '{\"small\":\"https://img3.doubanio.com/spic/s27264241.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s27264241.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s27264241.jpg\"}', 'undefined', '1', '[{\"count\":50,\"name\":\"Node.js\",\"title\":\"Node.js\"},{\"count\":30,\"name\":\"nodejs\",\"title\":\"nodejs\"},{\"count\":27,\"name\":\"JavaScript\",\"title\":\"JavaScript\"},{\"count\":25,\"name\":\"web开发\",\"title\":\"web开发\"},{\"count\":18,\"name\":\"node.js\",\"title\":\"node.js\"},{\"count\":17,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":10,\"name\":\"前端开发\",\"title\":\"前端开发\"},{\"count\":9,\"name\":\"node\",\"title\":\"node\"}]');
INSERT INTO `book` VALUES ('129', '730232560X', 'MySQL 5.6从零开始学', '', '', 'https://api.douban.com/v2/book/26832837', 'https://book.douban.com/subject/26832837/', 'https://img1.doubanio.com/f/shire/5522dd1f5b742d1e1394a17f44d590646b63871d/pics/book-default-medium.gif', '刘增杰,李坤', '', '清华大学出版社', '2013-9-1', '平装', 'CNY 79.00', '515', '', '', '', '9787302325604', '{\"small\":\"https://img1.doubanio.com/f/shire/9ec0301cff99c866e9b4f386743f612d594f1836/pics/book-default-small.gif\",\"large\":\"https://img3.doubanio.com/f/shire/5522dd1f5b742d1e1394a17f44d590646b63871d/pics/book-default-large.gif\",\"medium\":\"https://img1.doubanio.com/f/shire/5522dd1f5b742d1e1394a17f44d590646b63871d/pics/book-default-medium.gif\"}', 'undefined', '0', '[{\"count\":1,\"name\":\"Mysql\",\"title\":\"Mysql\"}]');
INSERT INTO `book` VALUES ('130', '730232929X', 'Effective MySQL之备份与恢复', 'Effective MySQL Backup and Recovery', '', 'https://api.douban.com/v2/book/25749741', 'https://book.douban.com/subject/25749741/', 'https://img1.doubanio.com/mpic/s27098828.jpg', 'Ronald Bradford', '张骏温', '清华大学出版社', '2013-8', '平装', '39.00元', '283', 'Ronald Bradford在关系数据库领域已经工作了二十余年。他具有深厚的专业背景和在数据库体系结构、性能调优以及使用ingres和oracle进行大型企业系统管理方面十多年的工作经验。在过去的13年中，他主要使用mysql这一全球最流行的开源数据库工作。他曾担任oracle公司(1996～1999)的咨询顾问，也曾担任MySQL有限公司(2006～2008)的高级顾问。他对mysql社区的贡献颇多，被认定为planet MySQL(2010)上最佳个人MySQL博客的博主。所获得的国际认可的荣誉包括：被授予oracle ace director(2010)和MySQL community member of the year(2009)。\nRonald不只有广泛的专业知识和咨询经验，也有把mysql的使用方法与心得分享出来的激情。从2006年开始，他就在做公开演讲，而在2010～2011年，他的演讲已经超过60场，足迹遍布20个国家。', 'mysql资深专家ronald bradford撰写的精品书籍《effective mysql之备份与恢复》涵盖了所有能够确保开发合理备份和恢复计划的选项，并对各选项做了详细说明，给出了语法示例。本书对照讲解不同的备份和恢复策略，将帮助您防止mysql数据因范围广泛的各种灾难受到损坏。\n主要内容：\n理解不同备份策略如何影响锁定和系统可用性；\n了解静态备份选项和时间点要求的重要性；\n体会使用mysql replication实现不同备份策略的优势；\n了解云计算中mysql方案的好处与风险；\n确定对最优数据保护需求具有决定性影响的重要业务因素；\n识别影响数据持久性和性能的重要配置变量；\n发现潜在灾难类型并制定可靠对策；\n使用压缩、流、增量和并行选项来优化备份方法 ；', '第1章 五分钟成为一名dba	1\n1.1 mysql备份	2\n1.1.1 确定数据库的大小	3\n1.1.2 选择锁策略	4\n1.1.3 运行时间	5\n1.1.4 组合信息	6\n1.2 执行mysql备份	6\n1.2.1 运行mysqldump	7\n1.2.2 安全地备份	9\n1.2.3 使用mysqldump的好处	9\n1.2.4 更多信息	10\n1.2.5 其他选项	10\n1.3 本章小结	11\n第2章 理解备份选项	13\n2.1 术语	14\n2.2 选择备份策略	15\n2.2.1 数据库的可用性	15\n2.2.2 存储引擎	16\n2.2.3 锁策略	16\n.2.2.4 mysql拓扑	20\n2.3 静态备份选项	20\n2.3.1 文件系统备份	21\n2.3.2 sql导出	22\n2.3.3 表抽取	30\n2.3.4 文件系统快照	31\n2.3.5 innodb热备份	37\n2.3.6 未讨论到的选项	53\n2.4 时间点要求	54\n2.4.1 二进制日志	55\n2.4.2 二进制日志文件的位置	56\n2.4.3 二进制日志备份的方案	57\n2.5 硬件方面的考虑事项	58\n2.6 数据源一致性	59\n2.7 备份的安全性	59\n2.8 本章小结	60\n第3章 理解灾难恢复的业务要求	61\n3.1 需求定义	62\n3.2 明确责任	63\n3.2.1 术语	64\n3.2.2 技术人员的责任	66\n3.2.3 决策者的责任	66\n3.2.4 确定依赖关系	67\n3.3 案例研究	67\n3.3.1 mysql拓扑	67\n3.3.2 备份和恢复策略	67\n3.3.3 一场真实的灾难	68\n3.3.4 技术成果	70\n3.3.5 决策过程	71\n3.3.6 必不可少的外部沟通	72\n3.4 为最糟的情形制定计划	72\n3.4.1 san的完全失败	73\n3.4.2 电力中断	73\n3.4.3 爆炸	74\n3.4.4 fbi的扣押	74\n3.4.5 断电	74\n3.4.6 人员因素	75\n3.4.7 人力资源	75\n3.5 制定一个策略计划	76\n3.6 本章小结	77\n第4章 使用mysql复制	79\n4.1 mysql复制的体系结构	80\n4.2 mysql复制的局限性	83\n4.2.1 复制的滞后	83\n4.2.2 一致性	85\n4.2.3 完备性	91\n4.3 复制设计的考虑事项	92\n4.3.1 二进制日志的行格式	92\n4.3.2 半同步复制	95\n4.4 复制备份的考虑事项	95\n4.4.1 innodb后台线程	98\n4.4.2 冷备份选项	98\n4.4.3 mysqldump选项	99\n4.4.4 文件系统快照选项	101\n4.4.5 mysql企业备份(meb)选项	102\n4.4.6 xtrabackup选项	102\n4.5 体系结构设计的考虑事项	103\n4.6 将出现的复制功能	104\n4.7 本章小结	105\n第5章 使用恢复选项	107\n5.1 测试简述	108\n5.2 明确所需的恢复类型	109\n5.2.1 mysql软件失败	109\n5.2.2 崩溃恢复	111\n5.2.3 myisam表恢复	114\n5.2.4 其他存储引擎	116\n5.2.5 表定义的恢复	117\n5.3 执行静态恢复	118\n5.3.1 mysql软件安装	119\n5.3.2 mysql数据	120\n5.4 执行一个时间点恢复	129\n5.4.1 二进制日志的位置	129\n5.4.2 独立恢复	131\n5.4.3 使用复制流	133\n5.4.4 二进制日志镜像	134\n5.5 恢复的验证	137\n5.6 备份和恢复的测试	139\n5.7 其他重要方面	140\n5.8 本章小结	141\n第6章 mysql的配置选项	143\n6.1 数据管理	144\n6.1.1 数据位置	144\n6.1.2 数据一致性	146\n6.1.3 二进制日志	150\n6.2 mysql复制	153\n6.3 恢复	156\n6.4 本章小结	158\n第7章 灾难场景	159\n7.1 处理mysql灾难	160\n7.2 著名的mysql灾难	161\n7.2.1 magnolia	162\n7.2.2 couch surfing	163\n7.2.3 journal space	164\n7.2.4 percona	165\n7.3 其他著名的数据灾难	167\n7.3.1 sidekick/microsoft的数据丢失	167\n7.3.2 github	168\n7.3.3 td bank	169\n7.4 通常的mysql灾难情形	170\n7.4.1 没有激活记录二进制日志	170\n7.4.2 单服务器	171\n7.4.3 适当的mysql安全	172\n7.4.4 适当的mysql配置	173\n7.4.5 删除mysql数据	176\n7.4.6 删除innodb数据文件	179\n7.4.7 删除mysql二进制日志	181\n7.5 现有备份和恢复过程的灾难	183\n7.5.1 mysql软件升级	183\n7.5.2 操作系统的安全补丁升级	184\n7.5.3 处理myisam毁坏	185\n7.5.4 丢失数据库模式	197\n7.5.5 在一个运行中的mysql实例上恢复备份	199\n7.6 处理innodb的特殊情况	202\n7.6.1 自动恢复	202\n7.6.2 innodb数据字典不一致	204\n7.6.3 自动恢复致使数据库服务器崩溃	205\n7.7 其他mysql情况	206\n7.7.1 复制不一致	206\n7.7.2 rds恢复失败	209\n7.8 常见的停机原因	210\n7.9 外部帮助	212\n7.10 本章小结	213\n第8章 优化备份和恢复	215\n8.1 示例备份环境	216\n8.2 使用压缩	218\n8.2.1 mysqldump	218\n8.2.2 mysql企业备份(meb)	222\n8.2.3 xtrabackup	225\n8.3 流备份	226\n8.3.1 利用ssh	226\n8.3.2 利用nc	228\n8.3.3 mysql企业备份(meb)	228\n8.3.4 xtrabackup	231\n8.4 远程备份	233\n8.4.1 mysqldump	233\n8.4.2 mysql企业备份(meb)	234\n8.4.3 xtrabackup	234\n8.5 并行处理	235\n8.5.1 mydumper	235\n8.5.2 xtrabackup	241\n8.6 增量备份	244\n8.6.1 mysql企业备份(meb)	244\n8.6.2 xtrabackup	248\n8.7 部分备份	252\n8.7.1 mysqldump	253\n8.7.2 mysql企业备份(meb)	253\n8.7.3 xtrabackup	253\n8.8 mysql备份安全	253\n8.9 体系结构的考虑	259\n8.10 本章小结	260\n第9章 云计算中的mysql	261\n9.1 amazon relational database service(rds)	262\n9.1.1 创建示例数据库	263\n9.1.2 mysql版本	264\n9.1.3 备份选项	264\n9.1.4 恢复选项	268\n9.2 google cloud sql	274\n9.2.1 创建样本数据库	274\n9.2.2 备份选项	276\n9.2.3 恢复选项	277\n9.3 hp cloud database as a service(dbaas)	277\n9.3.1 mysql的版本	278\n9.3.2 示例数据库的创建	279\n9.3.3 备份选项	280\n9.3.4 恢复选项	281\n9.4 云对备份和恢复的影响	281\n9.5 本章小结	283', '9787302329299', '{\"small\":\"https://img1.doubanio.com/spic/s27098828.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s27098828.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s27098828.jpg\"}', 'undefined', '1', '[{\"count\":3,\"name\":\"MySQL\",\"title\":\"MySQL\"},{\"count\":2,\"name\":\"数据库\",\"title\":\"数据库\"},{\"count\":1,\"name\":\"计算机\",\"title\":\"计算机\"}]');
INSERT INTO `book` VALUES ('131', '7302383669', 'MongoDB大数据处理权威指南（第2版）', '(美) 豪斯(Hows, D.)  等著', '', 'https://api.douban.com/v2/book/26269829', 'https://book.douban.com/subject/26269829/', 'https://img3.doubanio.com/mpic/s27876290.jpg', '(美) 豪斯(Hows, D.)  等著', '王肖峰  译', '清华大学出版社', '2015-1-1', '平装', '49.80元', '284', 'David Hows以优异的成绩毕业于澳大利亚新南威尔士州的卧龙岗大学。他第一次接触计算机，是在尝试不花钱的情况下改进家庭PC的性能。这促使他加入IT行业，David曾经担任过系统管理员、性能工程师、软件开发者、解决方案架构师和数据库工程师等职务。David也曾徒劳地尝试过多年足球，并且他的咖啡杯上写着“Grumble Bum”。\nPeterMembrey是一位特许IT研究员，他拥有15年使用Linux和开源解决方案解决现实中问题的经验。从17岁起他就是一位红帽认证工程师，并且他也有幸在Red Hat工作过，并编写了几本开源解决方案相关的书籍。他拥有利物浦大学的信息安全硕士学位，目前是香港理工大学的博士生，他的研究方向包括云计算、大数据、科学和安全。他与自己出色的妻子Sara和儿子Kaydyn一起居住在香港。尽管他的世界语一直不错，但广东话却在不断退步。\nEelcoPlugge是一位年轻的IET/BSC专家，他对IT安全领域非常感兴趣。在21岁时他就成为一位加密专家，目前从事移动设备管理行业，偶尔也会编写一些书籍。Eelco最近拿到了利物浦大学的计算机安全硕士学位，并持有多项专业证书。他对Linux、网络安全和加密技术都抱有极大的热情。Eelco与他的年轻家庭一起居住在荷兰。他喜欢寿司，讨厌过于复杂的事情。 Tim Hawkins曾在1993年创建了世界上第一个在线分类广告门户网站loot.com，之后负责管理雅虎欧盟的许多非媒体属性产品，例如搜索、本地搜索、邮件、消息和社交网络。他目前正在管理美国主要电子零售商的一个大型离岸团队，负责开发和部署下一代电子商务应用。他喜欢帽子，讨厌复杂性。', '本书根据MongoDB的最新版本做了相应更新，其中包含MongoDB n最新的所有特性，包括版本2.2中引入的聚集框架和版本2.4中引入的哈希索引。MongoDB是最流行的“大数据”NoSQL数据库技术，并且正处于发展中。来自10gen的David Hows以及具有丰富MongoDB开发经验的Peter Membrey和Eelco Plugge，组成了本书的专家团队，他们在本书中分享了自己的专业知识和经验，帮助你了解成为MongoDB专家所需的所有知识。', '第Ⅰ部分  MongoDB基础\n第1章  MongoDB简介	3\n1.1  了解MongoDB哲学	3\n1.1.1  使用正确的工具处理正确的工作	3\n1.1.2  天生缺少对事务的支持	5\n1.1.3  JSON和MongoDB	5\n1.1.4  采用非关系的方式	7\n1.1.5  选择性能还是特性	8\n1.1.6  在任何地方均可运行数据库	8\n1.2  将所有组合在一起	9\n1.2.1  生成或创建键	9\n1.2.2  使用键和值	9\n1.2.3  实现集合	10\n1.2.4  了解数据库	10\n1.3  了解特性列表	10\n1.3.1  使用面向文档存储(BSON)	11\n1.3.2  支持动态查询	11\n1.3.3  为文档创建索引	12\n1.3.4  使用地理空间索引	13\n1.3.5  分析查询	13\n1.3.6  就地更新信息	13\n1.3.7  存储二进制数据	14\n1.3.8  复制数据	14\n1.3.9  实施分片	14\n1.3.10  使用映射和归约函数	15\n1.3.11  全新的聚合框架	15\n1.4  获取帮助	15\n1.4.1  访问网站	15\n1.4.2  与MongoDB开发者沟通	16\n1.4.3  剪切和粘贴MongoDB代码	16\n1.4.4  在Google小组中寻找解决方案	16\n1.4.5  利用JIRA跟踪系统	16\n1.5  小结	16\n第2章  安装MongoDB	17\n2.1  选择版本	17\n2.2  在系统中安装MongoDB	18\n2.2.1  在Linux中安装MongoDB	18\n2.2.2  在Windows中安装MongoDB	19\n2.3  运行MongoDB	20\n2.3.1  先决条件	20\n2.3.2  研究安装目录布局	20\n2.3.3  使用MongoDB shell	21\n2.4  添加额外的驱动	22\n2.4.1  安装PHP驱动	22\n2.4.2  确认PHP安装正确	25\n2.4.3  安装Python驱动	26\n2.4.4  确认PyMongo安装正确	28\n2.5  小结	29\n第3章  数据模型	31\n3.1  设计数据库	31\n3.1.1  集合的更多细节	32\n3.1.2  使用文档	33\n3.1.3  在文档中内嵌或引用信息	34\n3.1.4  创建_id字段	35\n3.2  构建索引	36\n3.3  使用地理空间索引	37\n3.4  在真实世界中使用MongoDB	42\n3.5  小结	42\n第4章  使用数据	43\n4.1  浏览数据库	43\n4.2  在集合中插入数据	44\n4.3  查询数据	45\n4.3.1  使用点号	47\n4.3.2  使用函数sort、limit和skip	47\n4.3.3  使用固定集合、自然顺序和\n$natural	48\n4.3.4  获取单个文档	50\n4.3.5  使用聚集命令	50\n4.3.6  使用条件操作符	52\n4.3.7  使用正则表达式	59\n4.4  更新数据	59\n4.4.1  使用update()更新	60\n4.4.2  使用save()命令实现upsert	60\n4.4.3  自动更新信息	60\n4.4.4  指定匹配数组的位置	64\n4.4.5  原子操作	65\n4.4.6  以原子的方式修改和返回文档	66\n4.5  重命名集合	67\n4.6  删除数据	67\n4.7  引用数据库	68\n4.7.1  手动引用数据	68\n4.7.2  使用DBRef引用数据	70\n4.8  使用索引相关的函数	71\n4.8.1  学习索引相关的命令	72\n4.8.2  强制使用某个索引查询数据	72\n4.8.3  限制查询匹配	73\n4.9  小结	74\n第5章  GridFS	75\n5.1  背景	75\n5.2  使用GridFS	76\n5.3  开始使用命令行工具	76\n5.3.1  使用_id键	77\n5.3.2  使用文件名	77\n5.3.3  决定文件长度	78\n5.3.4  使用块大小	78\n5.3.5  处理上传日期	79\n5.3.6  生成文件的哈希值	79\n5.4  查看MongoDB中的数据	79\n5.4.1  使用搜索命令	81\n5.4.2  删除	81\n5.4.3  从MongoDB中获取文件	82\n5.4.4  mongofiles命令小结	82\n5.5  使用Python	82\n5.5.1  连接数据库	83\n5.5.2  访问单词	83\n5.6  在MongoDB中添加文件	84\n5.7  从GridFS中读取文件	84\n5.8  删除文件	85\n5.9  小结	85\n第Ⅱ部分  在开发中使用MongoDB\n第6章  PHP和MongoDB	89\n6.1  比较MongoDB和PHP中的\n文档	89\n6.2  MongoDB类	90\n6.3  连接和断开连接	91\n6.4  插入数据	92\n6.5  查询数据	94\n6.5.1  返回单个文档	94\n6.5.2  列出所有文档	95\n6.5.3  使用查询操作符	96\n6.5.4  查询特定信息	96\n6.5.5  排序、限制和忽略数据项	97\n6.5.6  统计匹配结果的数目	98\n6.5.7  使用聚集框架对数组分组	98\n6.5.8  使用hint()函数指定索引	99\n6.5.9  使用条件操作符重新定义查询	100\n6.5.10  正则表达式	106\n6.6  使用PHP修改数据	106\n6.6.1  使用update()函数更新数据	106\n6.6.2  节省更新操作的时间	108\n6.6.3  使用$ince增加特定键的值	108\n6.6.4  使用$set修改键值	109\n6.6.5  使用$unset删除字段	109\n6.6.6  使用$rename重命名字段	110\n6.6.7  在更新/插入期间使用$setOnInsert\n修改键值	110\n6.6.8  使用$push向指定字段中添加值	111\n6.6.9  使用$push和$each向某个键中\n添加多个值	111\n6.6.10  使用$addToSet将数据添加到\n数组中	112\n6.6.11  使用$pop从数组中删除元素	113\n6.6.12  使用$pull删除所有指定值	113\n6.6.13  同时删除多个元素	113\n6.6.14  使用save()函数更新/插入数据	114\n6.6.15  以原子的方式修改文档	115\n6.7  删除数据	116\n6.8  DBRef	118\n6.9  GridFS和PHP驱动	120\n6.9.1  存储文件	120\n6.9.2  在已存储的文件中添加元数据	121\n6.9.3  获取文件	121\n6.9.4  删除数据	122\n6.10  小结	122\n第7章  Python和MongoDB	123\n7.1  在Python中使用文档	123\n7.2  使用PyMongo模块	124\n7.3  连接和断开	124\n7.4  插入数据	125\n7.5  搜索数据	126\n7.5.1  搜索单个文档	126\n7.5.2  搜索多个文档	127\n7.5.3  使用点操作符	128\n7.5.4  返回字段	128\n7.5.5  使用sort()、limit()和skip()简化\n查询	129\n7.5.6  聚集查询	130\n7.5.7  使用hint()指定索引	132\n7.5.8  使用条件操作符重定义查询	133\n7.5.9  使用正则表达式执行搜索	137\n7.6  修改数据	138\n7.6.1  更新数据	139\n7.6.2  修改操作符	140\n7.6.3  使用save()函数快速保存文档	144\n7.6.4  以原子的方式修改文档	145\n7.6.5  使用参数	145\n7.7  删除数据	146\n7.8  在两个文档之间创建链接	146\n7.9  小结	149\n第8章  高级查询	151\n8.1  文本搜索	151\n8.1.1  文本搜索的代价和限制	152\n8.1.2  启用文本索引	152\n8.1.3  使用文本索引	153\n8.1.4  其他语言中的文本索引	158\n8.1.5  文本索引的复合索引	159\n8.2  聚集框架	161\n8.2.1  $group	162\n8.2.2  $sum	162\n8.2.3  $limit	163\n8.2.4  $match	164\n8.2.5  $sort	165\n8.2.6  $unwind	166\n8.2.7  $project	167\n8.2.8  $skip	168\n8.3  MapReduce	170\n8.3.1  MapReduce的工作方式	170\n8.3.2  创建测试文档	170\n8.3.3  使用map函数	170\n8.3.4  高级MapReduce	173\n8.3.5  调试MapReduce	174\n8.4  小结	175\n第Ⅲ部分  使用MongoDB处理大数据\n第9章  数据库管理	179\n9.1  使用管理工具	179\n9.1.1  mongo——MongoDB控制台	180\n9.1.2  使用第三方管理工具	180\n9.2  备份MongoDB服务器	180\n9.2.1  创建第一个备份	180\n9.2.2  备份单个数据库	182\n9.2.3  备份单个集合	182\n9.3  深入学习备份	183\n9.4  恢复单个数据库或集合	184\n9.4.1  恢复单个数据库	185\n9.4.2  恢复单个集合	185\n9.5  自动化备份	185\n9.5.1  使用本地数据存储	185\n9.5.2  使用远端数据存储(基于云)	187\n9.6  备份大数据库	188\n9.6.1  使用隐藏的辅助服务器备份\n数据	189\n9.6.2  使用日志文件系统创建快照	189\n9.6.3  使用卷管理器时的磁盘布局	191\n9.7  将数据导入MongoDB	191\n9.8  从MongoDB导出数据	192\n9.9  通过限制对MongoDB服务器的\n访问保护数据安全	194\n9.10  使用认证保护服务器	194\n9.10.1  添加admin用户	195\n9.10.2  启用认证	195\n9.10.3  在mongo控制台中执行认证	195\n9.10.4  MongoDB用户角色	196\n9.10.5  代理凭证	197\n9.10.6  修改用户凭证	197\n9.10.7  添加只读用户	198\n9.10.8  删除用户	198\n9.10.9  在PHP应用中认证连接	198\n9.11  管理服务器	199\n9.11.1  启动服务器	199\n9.11.2  重新配置服务器	200\n9.11.3  获得服务器版本	201\n9.11.4  获得服务器状态	201\n9.11.5  关闭服务器	203\n9.12  使用MongoDB日志文件	203\n9.13  验证和修复数据	204\n9.13.1  修复服务器	204\n9.13.2  验证单个集合	206\n9.13.3  修复集合验证错误	207\n9.14  升级MongoDB	209\n9.15  MongoDB的滚动升级	209\n9.16  监控MongoDB	209\n9.17  使用MongoDB管理服务	211\n9.18  小结	211\n第10章  优化	213\n10.1  优化服务器硬件	213\n10.1.1  了解MongoDB使用内存的\n方式	213\n10.1.2  了解工作集大小	214\n10.1.3  选择正确的数据库服务器\n硬件	214\n10.2  评估查询性能	214\n10.2.1  MongoDB分析器	215\n10.2.2  使用explain()分析特定的\n查询	217\n10.2.3  使用分析器和explain()优化\n查询	218\n10.3  管理索引	222\n10.3.1  显示索引	222\n10.3.2  创建简单的索引	223\n10.3.3  创建复合索引	223\n10.4  指定索引选项	224\n10.4.1  使用{background: true}在后台\n创建索引	224\n10.4.2  使用{unique: true}创建唯一键\n索引	225\n10.4.3  使用{dropdups: true}自动去重	225\n10.4.4  使用{sparse: true}创建稀疏\n索引	226\n10.4.5  TTL索引	226\n10.4.6  文本索引	227\n10.4.7  删除索引	227\n10.4.8  重建集合索引	227\n10.5  MongoDB选择索引的方式	228\n10.6  使用hint()强制使用特定的\n索引	229\n10.7  优化小对象的存储	229\n10.8  小结	230\n第11章  复制	231\n11.1  MongoDB复制的目标	231\n11.1.1  改善可扩展性	231\n11.1.2  改善持久性/可靠性	232\n11.1.3  提供隔离性	232\n11.2  复制基础	232\n11.2.1  主服务器的定义	233\n11.2.2  辅助服务器的定义	233\n11.2.3  仲裁服务器的定义	234\n11.3  深入学习oplog	234\n11.4  实现复制集	235\n11.4.1  创建复制集	236\n11.4.2  启动服务器成员	237\n11.4.3  向复制集中添加服务器	238\n11.4.4  添加仲裁服务器	241\n11.4.5  复制集链	242\n11.4.6  管理复制集	242\n11.4.7  为复制集成员设置选项	246\n11.4.8  从应用连接到复制集	248\n11.5  小结	251\n第12章  分片	253\n12.1  了解分片的需求	253\n12.2  对数据进行水平和垂直分区	254\n12.2.1  对数据进行垂直分区	254\n12.2.2  对数据进行水平分区	254\n12.3  分析一个简单的分片场景	255\n12.4  使用MongoDB实现分片	256\n12.4.1  创建分片设置	258\n12.4.2  在集群中添加新的分片	260\n12.4.3  从集群中移除分片服务器	262\n12.4.4  确定连接的方式	263\n12.4.5  列出分片服务器的状态	263\n12.4.6  使用复制集实现分片	264\n12.5  均衡器	264\n12.6  哈希片键	266\n12.7  标签分片	267\n12.8  小结	269', '9787302383666', '{\"small\":\"https://img3.doubanio.com/spic/s27876290.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s27876290.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s27876290.jpg\"}', 'undefined', '0', '[{\"count\":4,\"name\":\"mongodb\",\"title\":\"mongodb\"},{\"count\":2,\"name\":\"python\",\"title\":\"python\"},{\"count\":2,\"name\":\"大数据\",\"title\":\"大数据\"},{\"count\":2,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":1,\"name\":\"我的书架\",\"title\":\"我的书架\"},{\"count\":1,\"name\":\"正在阅读中，现在给我的感觉是内容感不够，翻译效果略待提高。\",\"title\":\"正在阅读中，现在给我的感觉是内容感不够，翻译效果略待提高。\"}]');
INSERT INTO `book` VALUES ('132', '7115333920', '中文版Photoshop CS6平面广告设计实战宝典505个必备秘技', '', '', 'https://api.douban.com/v2/book/26191131', 'https://book.douban.com/subject/26191131/', 'https://img1.doubanio.com/mpic/s27693678.jpg', '锐艺视觉', '', '人民邮电出版社', '2014-1-1', '平装', 'CNY 98.00', '464', '', '', '', '9787115333926', '{\"small\":\"https://img1.doubanio.com/spic/s27693678.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s27693678.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s27693678.jpg\"}', 'undefined', '0', '[{\"count\":1,\"name\":\"入门\",\"title\":\"入门\"}]');
INSERT INTO `book` VALUES ('133', '7115183392', 'HTML+CSS网页设计与布局从入门到精通', '', '', 'https://api.douban.com/v2/book/3171452', 'https://book.douban.com/subject/3171452/', 'https://img1.doubanio.com/mpic/s8828408.jpg', '温谦', '', '人民邮电出版社', '2008-8', '', '49.00元', '424', '', '《HTML+CSS网页设计与布局从入门到精通》紧密围绕网页设计师在制作网页过程中的实际需要和应该掌握的技术，全面介绍了使用HTML和CSS进行网页设计和制作的各方面内容和技巧。\n《HTML+CSS网页设计与布局从入门到精通》共分4个部分21章和两个附录，包括网页设计基础、HTML基础、CSS基础、CSS高级技术和CSS布局技术等内容。全书遵循Web标准，强调“表现”与“内容”的分离，抛弃了那些过时的HTML标记和属性，从更规范的角度全面、系统地介绍了网页设计制作方法与技巧。附录收录了网站发布与管理的知识和160个应用CSS时出现频度较高的英文单词及其中文解释。书中给出了大量详细的案例，并对案例进行分析，便于读者在理解的基础上，直接修改后使用。《HTML+CSS网页设计与布局从入门到精通》作者具备扎实的实践功底，行文细腻，对每一个技术细节以及每一个实际工作中可能遇到的难点和错误都进行了详细的说明，并给出了解决方案。\n《HTML+CSS网页设计与布局从入门到精通》附带学习光盘，收录了12个小时HTML和CSS多媒体教学录像和网页制作技术多媒体教学录像，辅助读者学习，达到事半功倍的效果。光盘还附带书中所有实例的素材文件、源代码和最终效果文件，修改后可直接使用。', '第1部分　HTML基础篇  第1章　网页设计基础知识  第2章　HTML网页文档结构  第3章　用HTML设置文本和图像  第4章　用HTML建立超链接(a)  第5章　用HTML创建表格第2部分　CSS基础篇  第6章　(X)HTML与CSS概述  第7章　CSS核心基础  第8章　手工编写与借助工具  第9章　CSS的高级特性  第10章　用CSS设置文本样式  第11章　用CSS设置图像效果  第12章　用CSS设置背景颜色与图像第3部分　CSS高级篇  第13章　CSS盒子模型  第14章　盒子的浮动与定位  第15章　用CSS设置表格样式  第16章　用CSS设置链接与导航菜单  第17章　用CSS建立表单  第18章　网页样式综合案例——灵活的电子相册第4部分　CSS布局篇  第19章　固定宽度布局剖析与制作  第20章　变宽度网页布局剖析与制作  第21章　网页布局综合案例——儿童用品网上商店附录A　网站发布与管理附录B　CSS英文小字典', '9787115183392', '{\"small\":\"https://img1.doubanio.com/spic/s8828408.jpg\",\"large\":\"https://img1.doubanio.com/lpic/s8828408.jpg\",\"medium\":\"https://img1.doubanio.com/mpic/s8828408.jpg\"}', 'undefined', '1', '[{\"count\":54,\"name\":\"html+css从入门到精通\",\"title\":\"html+css从入门到精通\"},{\"count\":32,\"name\":\"网页设计\",\"title\":\"网页设计\"},{\"count\":24,\"name\":\"html+css\",\"title\":\"html+css\"},{\"count\":16,\"name\":\"HTML\",\"title\":\"HTML\"},{\"count\":13,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":11,\"name\":\"前端\",\"title\":\"前端\"},{\"count\":8,\"name\":\"专业\",\"title\":\"专业\"},{\"count\":8,\"name\":\"电脑\",\"title\":\"电脑\"}]');
INSERT INTO `book` VALUES ('134', '7111463676', '零基础学HTML+CSS', '', '', 'https://api.douban.com/v2/book/26302658', 'https://book.douban.com/subject/26302658/', 'https://img3.doubanio.com/mpic/s27984621.jpg', '张熠', '', '机械工业出版社', '2014-7-1', '平装', '69', '389', '', '张熠等编著的这本《零基础学HTML+CSS（第3版）》站在零基础学习的角度，以通俗易懂的语言，结合丰富多彩的实例，来帮助初学者学习和掌握HTML语言和CSS样式设计。本书列举了大量的小型实例、综合实例，并包含3个项目案例，内容详尽、实例丰富、叙述清晰。\n本书主要分为四篇：第一篇为第1～9章，讲解了网页文字、字体、表格、段落、超级链接、图像、表单、框架、多媒体等技术；第二篇为第10～11章，对 DIV＋CSS的语法和相关属性进行了详细的解释和说明；第三篇为第12～20章，详细介绍了CSS的字体、文本、背景、边框、定位、列表、选择符等知识点；最后一篇为第21～24章，包括实战案例和实战面试，先通过3个案例介绍了网页的设计思路，然后通过面试题考查读者所学。\n本书适合作为中、高等学校师生以及各种网页设计培训班的教材或参考书，同时也可供网站建设专业人士参考使用。', '前言\n第一篇  HTML基础知识\n第1章  认识HTML语言\n第2章  常用HTML标记和格式\n第3章  字体标记\n第4章  文字布局\n第5章  图像和链接\n第6章  表单\n第7章  表格\n第8章  框架\n第9章  网页中的动态图文和多媒体\n第二篇  DIV＋CSS布局\n第10章  用DIV布局\n第11章  DIV与CSS结合\n第三篇  CSS部分\n第12章  CSS的基础知识\n第13章  字体设置和文本设置\n第14章  设置背景和尺寸\n第15章  设置外边距和内边距\n第16章  设置对象边框\n第17章  定位\n第18章  用CSS控制列表和表格\n第19章  滚动条和布局\n第20章  选择符\n第四篇  实践部分\n第21章  游戏网站布局\n第22章  企业网站布局\n第23章  博客主要页面布局\n第24章  面试题', '9787111463672', '{\"small\":\"https://img3.doubanio.com/spic/s27984621.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s27984621.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s27984621.jpg\"}', 'undefined', '0', '[{\"count\":1,\"name\":\"前端\",\"title\":\"前端\"},{\"count\":1,\"name\":\"张熠\",\"title\":\"张熠\"}]');
INSERT INTO `book` VALUES ('135', '7306055119', 'ROS入门实例', '', '', 'https://api.douban.com/v2/book/26755393', 'https://book.douban.com/subject/26755393/', 'https://img3.doubanio.com/mpic/s28551264.jpg', '（美）戈贝尔（Goebel,R.P.）', '（墨）罗哈斯（Rojas,J.）等', '中山大学出版社', '2016-1', '平装', '58', '230', 'R.Patrick Goebel，1991年获得认知心理学博士学位，现担任美国斯坦佛大学网络工程师职务，对机器人的设计构建与编程有深入的研究。', '本书是一部介绍机器人操作系统（机器人系统编程）的专业性读物。全书内容包括ROS基础知识，操作系统以及相关代码、模拟器安装，导航与路径规划，语音识别与合成，机器人视觉系统与视觉组合，Dynamixel伺服机。本书指导读者如何利用编程使机器人做一些神奇的事情。', '', '9787306055118', '{\"small\":\"https://img3.doubanio.com/spic/s28551264.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s28551264.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s28551264.jpg\"}', 'undefined', '0', '[]');
INSERT INTO `book` VALUES ('136', '7115291136', '游戏人工智能编程案例精粹', 'Programming Game AI by Example', '', 'https://api.douban.com/v2/book/19930152', 'https://book.douban.com/subject/19930152/', 'https://img3.doubanio.com/mpic/s22782570.jpg', 'Mat Buckland', '罗岱', '人民邮电出版社', '2012-9', '', '79.00元', '362', '', '《游戏人工智能编程案例精粹(修订版)》由Mat Buckland著，罗岱等人译，是游戏人工智能方面的经典之作，畅销多年。它展示了如何在游戏中利用专业人工智能技术，并针对实际困难问题，给出了强有力的解决方法。\n    《游戏人工智能编程案例精粹(修订版)》主要讲述如何使游戏中的角色具有智能的技术。本书首先介绍游戏角色的基本属性(包括速度、质量等物理属性)及常用数学方法。接着，深入探讨游戏智能体状态机的实现。通过简单足球游戏实例，本书给出用状态机实现游戏ai的例子。在图论部分，本书详细介绍图在游戏中的用途及各种不同的图搜索算法，并用一章的篇幅讨论了游戏中路径规划是如何完成的。此外，本书还对目标驱动的智能体的实现、触发器与模糊逻辑在游戏中的运用进行了讨论。为使智能体行为更加丰富、灵活、易于实现，本书还介绍了游戏脚本语言的优点，并以lua脚本语言为例进行了说明。\n    《游戏人工智能编程案例精粹(修订版)》适合对游戏ai开发感兴趣的爱好者和游戏ai开发人员阅读和参考。', '', '9787115291134', '{\"small\":\"https://img3.doubanio.com/spic/s22782570.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s22782570.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s22782570.jpg\"}', 'undefined', '0', '[{\"count\":65,\"name\":\"人工智能\",\"title\":\"人工智能\"},{\"count\":49,\"name\":\"游戏开发\",\"title\":\"游戏开发\"},{\"count\":24,\"name\":\"ai\",\"title\":\"ai\"},{\"count\":16,\"name\":\"游戏\",\"title\":\"游戏\"},{\"count\":14,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":8,\"name\":\"技术\",\"title\":\"技术\"},{\"count\":4,\"name\":\"程序设计\",\"title\":\"程序设计\"},{\"count\":3,\"name\":\"编程\",\"title\":\"编程\"}]');
INSERT INTO `book` VALUES ('137', '7121238365', 'ECMAScript6入门', '', '', 'https://api.douban.com/v2/book/25966265', 'https://book.douban.com/subject/25966265/', 'https://img3.doubanio.com/mpic/s28315395.jpg', '阮一峰', '', '电子工业出版社', '2014-8-1', '平装', 'CNY 49.00', '145', '阮一峰：著名技术博客作者，JavaScript专家。专注于网站开发技术，超过十年。畅销书《黑客与画家》《软件随想录》的译者。', '《ECMAScript6入门》全面介绍了ECMAScript6新引入的语法特性，覆盖了ECMAScript6与ECMAScript5的所有不同之处，对涉及的语法知识给予了详细介绍，并给出了大量简洁易懂的示例代码。\n《ECMAScript6入门》为中级难度，适合已有一定JavaScript语言基础的读者，用来了解这门语言的最新发展；也可当作参考手册，查寻新增的语法点。', '第一章ECMAScript6简介............................  1\nECMAScript和JavaScript的关系    3\nECMAScript的历史    4\n部署进度    5Traceur编译器    7\nECMAScript7    11\n第二章let和const命令..............................13\nlet命令    15\n块级作用域    17\nconst命令    19\n第三章 变量的解构赋值..............................21\n数组的解构赋值    23\n对象的解构赋值    25\n用途    27\n第四章 字符串的扩展 ................................31\ncodePointAt方法    33\nString.fromCodePoint方法    34\n字符的Unicode表示法    35\n正则表达式的u修饰符    36\ncontains(),startsWith(),endsWith()    36\nrepeat()    37\n正则表达式的y修饰符    38\n模板字符串    39\n第五章 数值的扩展 ..................................41\n二进制和八进制数值表示法    43\nNumber.isFinite(),Number.isNaN()    43\nNumber.parseInt(),Number.parseFloat()    44\nNumber.isInteger()和安全整数    44\nMath对象的扩展    45\nMath.trunc()    45\n数学方法    45\n第六章 数组的扩展 ..................................47\nArray.from()    49\nArray.of()    50\n数组实例的fnd()和fndIndex()    50\n数组实例的fll()    51\n数组实例的entries()，keys()和values()    52\n数组推导    53\nArray.observe()，Array.unobserve()    55\n第七章 对象的扩展 ..................................57\nObject.is()    59\nObject.assign()    59\n__proto__属性，Object.setPrototypeOf()，\nObject.getPrototypeOf()    60\n__proto__属性    60\nObject.setPrototypeOf()    61\nObject.getPrototypeOf()    61\n增强的对象写法    62\n属性名表达式    63Symbol    64\nProxy    66Object.observe()，Object.unobserve()    68\n第八章 函数的扩展 ..................................71\n函数参数的默认值    73rest参数    74\n扩展运算符    75箭头函数    77\n第九章 Set和Map数据结构..........................81Set    83Map    86\n基本用法    86\n属性和方法    88\n遍历    89WeakMap    91\n第十章Iterator和for...of循环.......................93\nIterator（遍历器）    95for...of循环    97\n第十一章Generator函数..............................103\n含义    105\nnext方法的参数    108\n异步操作的应用    109\nfor...of循环    112\nyield*语句    112\n第十二章Promise对象 ...............................115\n基本用法    117\n链式操作    120\ncatch方法：捕捉错误    121\nPromise.all方法    121\nPromise.resolve方法    122\nasync函数    123\n第13章  Class和Module.............................125\nClass    127\nModule的基本用法    129\nexport和import    129\n模块的整体加载    130\nexportdefault语句    131\n模块的继承    132\n参考链接.............................................135\n索引.................................................143', '9787121238369', '{\"small\":\"https://img3.doubanio.com/spic/s28315395.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s28315395.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s28315395.jpg\"}', 'undefined', '0', '[{\"count\":55,\"name\":\"JavaScript\",\"title\":\"JavaScript\"},{\"count\":30,\"name\":\"ECMAScript6\",\"title\":\"ECMAScript6\"},{\"count\":26,\"name\":\"前端\",\"title\":\"前端\"},{\"count\":12,\"name\":\"编程\",\"title\":\"编程\"},{\"count\":11,\"name\":\"计算机\",\"title\":\"计算机\"},{\"count\":8,\"name\":\"Javascript\",\"title\":\"Javascript\"},{\"count\":6,\"name\":\"Web\",\"title\":\"Web\"},{\"count\":6,\"name\":\"程序设计\",\"title\":\"程序设计\"}]');
INSERT INTO `book` VALUES ('138', '9787112036', '建筑工程造价管理', '', '', 'https://api.douban.com/v2/book/20299932', 'https://book.douban.com/subject/20299932/', 'https://img3.doubanio.com/mpic/s23477522.jpg', '', '', '', '', '', '', '', '', '建筑工程造价管理，ISBN：9789787112038，作者：', '', '9789787112038', '{\"small\":\"https://img3.doubanio.com/spic/s23477522.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s23477522.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s23477522.jpg\"}', 'undefined', '0', '[]');
INSERT INTO `book` VALUES ('139', '7111478320', 'HBase企业应用开发实战', '', '', 'https://api.douban.com/v2/book/25985471', 'https://book.douban.com/subject/25985471/', 'https://img3.doubanio.com/mpic/s27466344.jpg', '马延辉,孟鑫,李立松', '', '机械工业出版社', '2014-9', '', '89.00', '', '马延辉　资深Hadoop技术专家，对Hadoop生态系统相关技术有深刻的理解。曾就职于淘宝、Answers.com、暴风影音等知名互联网公司，从事Hadoop相关的技术工作，在企业级大数据系统的研发、运维和管理方面积累了丰富的实战经验。开源HBase监控工具Ella的作者。在国内Hadoop社区内非常活跃，经常在各种会议和沙龙上做技术分享，深受欢迎。现在专注于大数据技术在传统行业的落地，致力于大数据技术的普及和推广。\n孟鑫　资深Hadoop技术专家，在软件行业从业近10年，对海量数据处理技术有着深刻的认识，曾负责Hadoop平台建设工作，在Hadoop开发和运维方面积累了大量的实战经验。于2013年获取了Cloudera的Hadoop Developer认证，多次到企业和社区去分享Hadoop、HBase等方面的技术知识和经验。对技术拥有极大的兴趣，热衷于研究各种新技术，乐于总结和分享经验及教训。目前从事管理工作，但依然热衷于产品设计和实现。\n李立松　资深Hadoop技术专家，Easyhadoop技术社区创始人之一，对HDFS、MapReduce、HBase、Hive等Hadoop生态系统中的技术有比较深入的研究，在Hadoop开发方面积累了丰富的经验。曾就职于暴风影音，负责大数据平台开发与应用，担任大数据项目负责人。现在就职于缔元信，担任Hadoop高级工程师，负责缔元信DMP平台的研发工作。', '本书特色：\n国内资深Hadoop技术专家实践经验结晶，完全从企业实际生产环境和需求出发，旨在帮助企业真正解决大数据的落地问题；\n系统介绍HBase的功能使用、框架设计、基本原理和高级特性；详细讲解使用HBase设计大型数据应用系统的实践方法和技巧；深刻总结系统运维、监控和性能调优的最佳实践。\n本书强调HBase在企业的实际应用，立足于企业的实际生产环境，旨在帮助企业切实解决大数据技术如何落地的问题。三位作者都是奋战在中国大数据技术一线的实践派专家，本书是他们实践经验的结晶。\n本书内容在三个维度上具有重要特色：功能维度，从HBase的安装配置、参数设置，到数据模型、表结构设计、客户端使用、高级特性，本书做了系统且详尽的介绍；实战维度，不仅通过3个典型的应用案例详细讲解了如何使用HBase设计大型的数据应用系统，而且还结合实际生产系统讲解了HBase的集群运维、监控和性能调优；理论维度，则深入分析了HBase、框架设计、模式设计和基本原理。可谓是理论与实践完美结合，深度与广度兼备！\n【名家推荐】\n本书作者在Hadoop开发和运维领域工作近4年，积累了丰富的经验，同时也对Hadoop技术人员在学习过程中可能会遇到的问题有一定的了解，在此基础上写了这本书。从如何用好HBase出发，首先介绍设计原理和应用场景，让读者了解HBase适合什么场景不适合什么场景，然后再介绍应用编程、性能优化和生产环境中的运维经验，可谓由浅入深，循序渐进，值得推荐！\n—— 查礼 博士\n中国大数据技术大会（原Hadoop in China）主席，中国计算机学会大数据专家委员会委员，中科院计算所副研究员\n近几年，大数据和开源越来越受到各行各业的关注，而作为大数据中不可替代的重中之重，Hadoop及其周边生态，也逐渐从互联网公司向传统行业过渡。本书的几位作者都是在Hadoop与大数据领域深入工作多年的践行者，既有丰富的理论知识，又有多年工作的实战经验。本书着重介绍了HBase的工作原理和设计架构，同时在实际工作的应用场景上亦着墨很重，大数据的神秘不仅仅在于具体的技术细节，更多的是由于它是个新生事物，很多人并不很清楚大数据的技术架构应如何设计，应用场景如何，而我这几位好友结合自己在实际工作中的宝贵经验，通过撰写本书为广大爱好者解答了这一难题。本书是不可多得的理论与实践完美结合的技术书籍。\n——　向磊　phphiveadmin作者，汉云数衍创始人\n大数据的概念已经逐渐深入人心，从互联网行业到传统行业，已经掀起一股“数据驱动商业价值”的热潮。大数据需要落地，需要开源技术来驱动新一轮的变革，而HBase作为大数据落地过程中的神兵利器，已经一次又一次证明了其巨大价值。本书不同于其他HBase的翻译版书籍，由来自国内互联网最前沿的实战派资深人士撰写而成，融合了自身的实战经验，更契合中国企业应用HBase技术的实情。本书由浅入深，结合理论阐述与案例剖析，如同一壶香茶，值得细细品咂。\n——　数盟社区　致力于为推崇“数据价值”的企业及个人打造最好的数据科学交流平台', '前　言\n第一部分　基础篇\n第1章　认识HBase  2\n1.1　理解大数据背景  2\n1.1.1　什么是大数据  3\n1.1.2　为何大数据至关重要  4\n1.1.3　NoSQL在大数据中扮演的角色  4\n1.2　HBase是什么  6\n1.2.1　HBase的发展历史  6\n1.2.2　HBase的发行版本  7\n1.2.3　HBase的特性  9\n1.3　HBase与Hadoop的关系  10\n1.4　HBase的核心功能模块  12\n1.4.1　客户端Client  12\n1.4.2　协调服务组件ZooKeeper  13\n1.4.3　主节点HMaster  13\n1.4.4　Region节点HRegionServer  13\n1.5　HBase的使用场景和经典案例  14\n1.5.1　搜索引擎应用  15\n1.5.2　增量数据存储  15\n1.5.3　用户内容服务  17\n1.5.4　实时消息系统构建  18\n1.6　本章小结  18\n第2章　HBase安装与配置  19\n2.1　先决条件  19\n2.2　HBase运行模式  23\n2.2.1　单机模式  23\n2.2.2　分布式模式  24\n2.3　HBase的Web UI  31\n2.4　HBase Shell工具使用  31\n2.5　停止HBase集群  33\n2.6　本章小结  33\n第3章　数据模型  34\n3.1　两类数据模型  34\n3.1.1　逻辑模型  35\n3.1.2　物理模型  35\n3.2　数据模型的重要概念  36\n3.2.1　表  36\n3.2.2　行键  37\n3.2.3　列族  38\n3.2.4　单元格  38\n3.3　数据模型的操作  38\n3.3.1　读Get  39\n3.3.2　写Put  39\n3.3.3　扫描Scan  39\n3.3.4　删除Delete  40\n3.4　数据模型的特殊属性  40\n3.4.1　版本  40\n3.4.2　排序  42\n3.4.3　列的元数据  42\n3.4.4　连接查询  43\n3.4.5　计数器  43\n3.4.6　原子操作  43\n3.4.7　事务特性ACID  43\n3.4.8　行锁  45\n3.4.9　自动分区  45\n3.5　CAP原理与最终一致性  46\n3.6　本章小结  47\n第4章　HBase表结构设计  48\n4.1　模式创建  48\n4.2　Rowkey设计  49\n4.3　列族定义  51\n4.3.1　可配置的数据块大小  51\n4.3.2　数据块缓存  52\n4.3.3　布隆过滤器  52\n4.3.4　数据压缩  53\n4.3.5　单元时间版本  53\n4.3.6　生存时间  54\n4.4　模式设计实例  54\n4.4.1　实例1：动物分类  54\n4.4.2　实例2：店铺与商品  56\n4.4.3　实例3：网上商城用户消费记录  57\n4.4.4　实例4：微博用户与粉丝  58\n4.5　本章小结  60\n第5章　HBase客户端  61\n5.1　精通原生Java客户端  61\n5.1.1　客户端配置  62\n5.1.2　创建表  69\n5.1.3　删除表  70\n5.1.4　插入数据  70\n5.1.5　查询数据  72\n5.1.6　删除数据  76\n5.1.7　过滤查询  77\n5.2　使用HBase Shell工具操作HBase  79\n5.2.1　命令分类  79\n5.2.2　常规命令  80\n5.2.3　DDL命令  81\n5.2.4　DML命令  82\n5.2.5　工具命令Tools  86\n5.2.6　复制命令  87\n5.2.7　安全命令  87\n5.3　使用Thrift客户端访问HBase  88\n5.3.1　Thrift与Thrift2区别  88\n5.3.2　安装与部署Thrift2  89\n5.3.3　Python使用案例  93\n5.4　通过REST客户端访问HBase  95\n5.4.1　启动服务  95\n5.4.2　使用REST访问example表  96\n5.5　使用MapReduce批量操作HBase  97\n5.5.1　三种访问模式  98\n5.5.2　实现MapReduce API  98\n5.5.3　HBase作为输入源示例  99\n5.5.4　HBase作为输出源示例  101\n5.5.5　HBase作为共享源示例  103\n5.6　通过Web UI工具查看HBase状态  106\n5.6.1　Master状态界面  106\n5.6.2　RegionServer状态界面  107\n5.6.3　ZooKeeper统计信息页面  109\n5.7　其他客户端  110\n5.8　本章小结  110\n第二部分　实战篇\n第6章　整合SQL引擎层  114\n6.1　NoSQL背景知识  114\n6.1.1　什么是NoSQL  114\n6.1.2　将SQL整合到HBase的原因  115\n6.1.3　基于HBase的SQL引擎实现  116\n6.2　Hive整合HBase的实现  119\n6.2.1　认识Hive  119\n6.2.2　Hive整合HBase的环境准备  122\n6.2.3　Linux环境下重新编译Hive  123\n6.2.4　Hive参数配置  125\n6.2.5　启动Hive  127\n6.2.6　Hive与HBase整合后的框架如何使用  127\n6.2.7　HBase到Hive的字段映射  133\n6.2.8　多列与Hive Map类型  134\n6.3　查询引擎Phoenix  137\n6.3.1　认识Phoenix  138\n6.3.2　Phoenix安装环境准备  141\n6.3.3　Phoenix安装部署  142\n6.3.4　Phoenix源码编译  143\n6.3.5　Phoenix中SQLLine的快速使用  149\n6.3.6　使用JDBC访问Phoenix  153\n6.4　对象映射框架Kundera  155\n6.4.1　认识Kundera  155\n6.4.2　Kundera的客户端API快速使用  158\n6.4.3　Kundera模块介绍  161\n6.4.4　Kundera的REST访问方式  162\n6.5　分布式SQL引擎Lealone  165\n6.5.1　认识Lealone  165\n6.5.2　Lealone的安装部署  166\n6.5.3　通过JDBC访问Lealone  168\n6.5.4　通过Python访问Lealone  169\n6.5.5　Lealone特有的建表语法  170\n6.6　本章小结  171\n第7章　构建音乐站用户属性库  173\n7.1　案例背景  173\n7.1.1　音乐站  173\n7.1.2　需求概述  175\n7.1.3　需求范围和系统边界  175\n7.1.4　需求详述  176\n7.1.5　名词解释  180\n7.2　概要设计  181\n7.2.1　设计目标  181\n7.2.2　数据规模假设  181\n7.2.3　功能指标  182\n7.2.4　系统流程  182\n7.3　表结构设计  183\n7.3.1　功能抽象  183\n7.3.2　逻辑结构  184\n7.3.3　Rowkey设计  188\n7.3.4　列族设计  188\n7.3.5　版本定义  188\n7.3.6　优化属性定义  188\n7.4　数据加载  189\n7.4.1　加载流程  189\n7.4.2　Mapper类  190\n7.4.3　Main类  192\n7.4.4　运行  193\n7.5　数据检索  193\n7.5.1　HBaseTable  193\n7.5.2　HBaseAdmin  193\n7.5.3　几种检索类型  195\n7.6　后台查询  198\n7.6.1　二级索引实现  198\n7.6.2　后台查询系统  205\n7.7　本章小结  206\n第8章　构建广告实时计算系统  208\n8.1　理解广告数据和流处理框架  208\n8.1.1　网络广告的几大特性  209\n8.1.2　网络广告的数据类型  210\n8.1.3　流处理框架  211\n8.1.4　背景与需求描述  217\n8.2　概要设计  218\n8.2.1　设计目标  219\n8.2.2　主要功能  219\n8.2.3　系统架构  219\n8.3　详细设计  221\n8.3.1　表结构设计  221\n8.3.2　功能模块设计  222\n8.4　核心功能实现  223\n8.4.1　规划集群环境部署  223\n8.4.2　安装ZooKeeper集群  225\n8.4.3　安装Kafka分布式集群  228\n8.4.4　实现Kafka生产者  231\n8.4.5　安装Storm分布式集群  233\n8.4.6　查看集群节点部署情况  240\n8.4.7　基于Storm-kafka中间件实现计算逻辑  240\n8.4.8　如何使用HBase中统计数据  251\n8.5　本章小结  252\n第三部分　高级篇\n第9章　核心概念  254\n9.1　核心结构  254\n9.1.1　B+树  255\n9.1.2　LSM树  255\n9.1.3　两种结构本质区别  257\n9.2　底层持久化  258\n9.2.1　存储基本架构  258\n9.2.2　HDFS文件  259\n9.2.3　Region切分  264\n9.2.4　合并  265\n9.2.5　HFile格式  266\n9.2.6　KeyValue格式  269\n9.3　预写日志  270\n9.3.1　概要流程  270\n9.3.2　相关Java类  271\n9.3.3　日志回放  274\n9.3.4　日志一致性  275\n9.4　写入流程  276\n9.4.1　客户端  276\n9.4.2　服务器端  281\n9.5　查询流程  286\n9.5.1　两种查询操作  286\n9.5.2　客户端  286\n9.5.3　服务器端  287\n9.6　数据备份  291\n9.6.1　备份机制架构  292\n9.6.2　故障恢复  292\n9.7　数据压缩  294\n9.7.1　支持的压缩算法  295\n9.7.2　使用配置  295\n9.8　本章小结  296\n第10章　HBase高级特性  297\n10.1　过滤器  297\n10.1.1　过滤器的两类参数  297\n10.1.2　比较器  298\n10.1.3　列值过滤器  300\n10.1.4　键值元数据过滤器  300\n10.1.5　行键过滤器  303\n10.1.6　功能过滤器  303\n10.1.7　Thrift使用过滤器  304\n10.1.8　过滤器总结  309\n10.2　计数器  310\n10.2.1　使用Shell操作计数器  310\n10.2.2　基于单列的计数器  312\n10.2.3　多列计数器  313\n10.3　协处理器  314\n10.3.1　认识协处理器  315\n10.3.2　观察者Observer  316\n10.3.3　终端EndPoint  318\n10.3.4　协处理器部署  320\n10.4　Schema设计要点  323\n10.4.1　行键设计  323\n10.4.2　列族设计  325\n10.5　二级索引  325\n10.5.1　Client-managed方式  326\n10.5.2　ITHBase实现  326\n10.5.3　IHBase实现  329\n10.5.4　Coprocessor方式  329\n10.5.5　MapReduce两种方式  330\n10.6　布隆过滤器  330\n10.6.1　基本概念  331\n10.6.2　配置布隆过滤器  332\n10.6.3　使用布隆过滤器  333\n10.7　负载均衡  333\n10.7.1　全局计划  334\n10.7.2　随机分配计划  337\n10.7.3　批量启动分配计划  337\n10.7.4　通过Shell控制负载均衡  338\n10.8　批量加载  338\n10.8.1　准备数据：importtsv  338\n10.8.2　加载数据：completebulkload  340\n10.9　本章小结  340\n第11章　集群运维管理  341\n11.1　HBase常用工具  341\n11.1.1　文件检测修复工具hbck  342\n11.1.2　文件查看工具hfile  346\n11.1.3　WAL日志查看工具hlog  348\n11.1.4　压缩测试工具CompressionTest  349\n11.1.5　数据迁移工具CopyTable  350\n11.1.6　导出工具export  351\n11.1.7　导入工具Import  351\n11.1.8　日志回放工具WALPlayer  351\n11.1.9　行数统计工具RowCounter  352\n11.2　Region和RegionServer管理  353\n11.2.1　大合并工具major_compact  353\n11.2.2　Region合并工具Merge  354\n11.2.3　下线节点  354\n11.2.4　滚动重启  355\n11.3　性能指标Metrics  356\n11.3.1　Master Metrics  357\n11.3.2　RegionServer Metrics  357\n11.3.3　RPC Metrics  358\n11.3.4　JVM Metrics  359\n11.3.5　集群属性Metrics  360\n11.4　监控系统Ganglia  360\n11.4.1　HBase监控指标  360\n11.4.2　安装、部署和使用Ganglia  361\n11.5　HBase管理扩展JMX  366\n11.5.1　如何使用JMX  366\n11.5.2　基于JMX的监控工具Ella  368\n11.6　报警工具Nagios  371\n11.7　故障处理  376\n11.7.1　问题咨询渠道  377\n11.7.2　常用日志信息  377\n11.7.3　常用故障调试工具  379\n11.7.4　客户端故障排查  384\n11.7.5　MapReduce故障排查  386\n11.7.6　网络故障排查  387\n11.7.7　RegionServer相关问题解决  387\n11.7.8　Master相关问题解决  391\n11.7.9　ZooKeeper相关问题解决  392\n11.8　集群备份  392\n11.8.1　冷备份  393\n11.8.2　热备份之Replication  393\n11.8.3　热备份之CopyTable  393\n11.8.4　热备份之Export  393\n11.9　本章小结  393\n第12章　性能调优  395\n12.1　硬件和操作系统调优  395\n12.1.1　配置内存  395\n12.1.2　配置CPU  396\n12.1.3　操作系统  396\n12.2　网络通信调优  399\n12.2.1　配置交换机  399\n12.2.2　添加机架感知  401\n12.3　JVM优化  402\n12.3.1　Java垃圾回收算法  402\n12.3.2　Java垃圾收集器  403\n12.3.3　垃圾回收器的选择  405\n12.3.4　JVM参数设置  406\n12.4　HBase查询优化  408\n12.4.1　设置Scan缓存  408\n12.4.2　显式地指定列  409\n12.4.3　关闭ResultScanner  410\n12.4.4　禁用块缓存  410\n12.4.5　优化行键查询  410\n12.4.6　通过HTableTool访问  410\n12.4.7　使用批量读  411\n12.4.8　使用Filter降低客户端压力  412\n12.4.9　使用Coprocessor统计行数  412\n12.4.10　缓存查询结果  413\n12.5　HBase写入优化  413\n12.5.1　关闭写WAL日志  413\n12.5.2　设置AutoFlush  414\n12.5.3　预创建Region  415\n12.5.4　延迟日志flush  419\n12.5.5　通过HTableTool访问  419\n12.5.6　使用批量写  420\n12.6　HBase基本核心服务优化  421\n12.6.1　优化分裂操作  421\n12.6.2　优化合并操作  423\n12.7　HBase配置参数优化  423\n12.7.1　设置RegionServer Handler数量  423\n12.7.2　调整BlockCache大小  425\n12.7.3　设置MemStore的上下限  426\n12.7.4　调整影响合并的文件数  427\n12.7.5　调整MemStore的flush因子  427\n12.7.6　调整单个文件大小  427\n12.7.7　调整ZooKeeper Session的有效时长  428\n12.8　分布式协调系统ZooKeeper优化  428\n12.8.1　配置ZooKeeper节点数  428\n12.8.2　独立ZooKeeper集群  429\n12.9　表设计优化  430\n12.9.1　开启布隆过滤器  430\n12.9.2　调整列族块大小  430\n12.9.3　设置In Memory属性  432\n12.9.4　调整列族最大版本数  434\n12.9.5　设置TTL属性  435\n12.10　其他优化  436\n12.10.1　关闭MapReduce的预测执行功能  436\n12.10.2　修改负载均衡执行周期  438\n12.11　性能测试  438\n12.12　本章小结  441\n附录A　HBase配置参数介绍  442\n附录B　Phoenix SQL语法详解  451\n附录C　YCSB编译安装  468', '9787111478324', '{\"small\":\"https://img3.doubanio.com/spic/s27466344.jpg\",\"large\":\"https://img3.doubanio.com/lpic/s27466344.jpg\",\"medium\":\"https://img3.doubanio.com/mpic/s27466344.jpg\"}', 'undefined', '0', '[{\"count\":11,\"name\":\"HBase\",\"title\":\"HBase\"},{\"count\":3,\"name\":\"hbase\",\"title\":\"hbase\"},{\"count\":2,\"name\":\"数据库\",\"title\":\"数据库\"},{\"count\":1,\"name\":\"大数据\",\"title\":\"大数据\"}]');

-- ----------------------------
-- Table structure for book_apply
-- ----------------------------
DROP TABLE IF EXISTS `book_apply`;
CREATE TABLE `book_apply` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `user_name` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `user_dept` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_latvian_ci DEFAULT NULL COMMENT '申请部门',
  `book_id` int(11) DEFAULT NULL,
  `book_title` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `book_count` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `apply_time` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `apply_status` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '0申请中,1申请通过,2申请失败',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

-- ----------------------------
-- Records of book_apply
-- ----------------------------
INSERT INTO `book_apply` VALUES ('1', '2', 'admin', '数据团队', '136', '游戏人工智能编程案例精粹', '5', '2016-08-22 14:16:23', '1');
INSERT INTO `book_apply` VALUES ('3', '2', 'admin', '数据团队', '133', 'HTML+CSS网页设计与布局从入门到精通', '1', '2016-08-22 17:34:43', '0');
INSERT INTO `book_apply` VALUES ('4', '3', 'cjsong', 'null', '133', 'HTML+CSS网页设计与布局从入门到精通', '1', '2016-08-22 17:35:58', '1');
INSERT INTO `book_apply` VALUES ('5', '1', 'book', 'data', '130', 'Effective MySQL之备份与恢复', '777', '2016-08-23 17:11:42', '0');
INSERT INTO `book_apply` VALUES ('6', '3', 'wtoip', '数据团队', '122', 'C程序设计语言', '1', '2016-08-23 17:20:16', '0');
INSERT INTO `book_apply` VALUES ('7', '3', 'wtoip', '数据团队', '118', '响应式Web设计', '2', '2016-08-23 17:20:43', '0');
INSERT INTO `book_apply` VALUES ('8', '3', 'wtoip', '数据团队', '130', 'Effective MySQL之备份与恢复', '1', '2016-08-24 09:32:43', '0');
INSERT INTO `book_apply` VALUES ('9', '3', 'wtoip', '数据团队', '123', 'Linux命令行与shell脚本编程大全', '3', '2016-08-24 14:40:42', '0');

-- ----------------------------
-- Table structure for book_lend_history
-- ----------------------------
DROP TABLE IF EXISTS `book_lend_history`;
CREATE TABLE `book_lend_history` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `user_name` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `book_id` int(11) DEFAULT NULL,
  `book_title` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `revert_time` varchar(250) COLLATE utf8_bin DEFAULT NULL COMMENT '归还时间',
  `lend_time` varchar(250) COLLATE utf8_bin DEFAULT NULL COMMENT '借阅时间',
  `book_status` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '归还状态 0 借阅申请中 1 借阅成功 未归还, 2 已归还, 3 拒绝借阅',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

-- ----------------------------
-- Records of book_lend_history
-- ----------------------------
INSERT INTO `book_lend_history` VALUES ('1', '3', 'wtoip', '133', 'HTML+CSS网页设计与布局从入门到精通', '2016-08-26 08:52:44', '2016-08-24 09:31:55', '2');
INSERT INTO `book_lend_history` VALUES ('3', '3', 'wtoip', '128', 'Node.js实战', '2016-09-05 15:33:28', '2016-08-29 13:45:25', '2');

-- ----------------------------
-- Table structure for book_stock
-- ----------------------------
DROP TABLE IF EXISTS `book_stock`;
CREATE TABLE `book_stock` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `book_id` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `book_title` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '书名',
  `book_count` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '书本总数',
  `book_lend_count` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '借出数量',
  `book_stock` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '库存数量',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

-- ----------------------------
-- Records of book_stock
-- ----------------------------
INSERT INTO `book_stock` VALUES ('1', '110', 'Python网络数据采集', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('2', '111', 'Java从入门到精通', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('3', '112', 'Java并发编程实战', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('4', '113', 'Java基础入门', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('5', '114', '数据结构与算法分析', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('6', '115', 'Android应用性能优化', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('7', '116', 'PHP和MySQL Web开发(原书第4版)', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('8', '117', 'PHP核心技术与最佳实践', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('9', '118', '响应式Web设计', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('10', '119', 'HTML5权威指南', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('11', '120', '代码整洁之道', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('12', '121', '设计模式', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('13', '122', 'C程序设计语言', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('14', '123', 'Linux命令行与shell脚本编程大全', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('15', '124', 'Linux内核设计与实现(原书第3版)', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('16', '125', 'Node学习指南', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('17', '126', 'Node应用程序构建', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('18', '127', 'JavaScript应用程序设计', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('19', '128', 'Node.js实战', '6', '0', '6');
INSERT INTO `book_stock` VALUES ('20', '129', 'MySQL 5.6从零开始学', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('21', '130', 'Effective MySQL之备份与恢复', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('22', '131', 'MongoDB大数据处理权威指南（第2版）', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('23', '132', '中文版Photoshop CS6平面广告设计实战宝典505个必备秘技', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('24', '133', 'HTML+CSS网页设计与布局从入门到精通', '2', '0', '2');
INSERT INTO `book_stock` VALUES ('25', '134', '零基础学HTML+CSS', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('26', '135', 'ROS入门实例', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('27', '136', '游戏人工智能编程案例精粹', '6', '0', '6');
INSERT INTO `book_stock` VALUES ('28', '137', 'ECMAScript6入门', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('29', '138', '建筑工程造价管理', '0', '0', '0');
INSERT INTO `book_stock` VALUES ('30', '139', 'HBase企业应用开发实战', '0', '0', '0');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `phone_num` bigint(15) DEFAULT NULL,
  `dept` varchar(255) DEFAULT NULL,
  `role` int(2) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'book', 'book', '125365754667', 'data', '0');
INSERT INTO `user` VALUES ('2', 'admin', 'admin', '13826414358', '数据团队', '1');
INSERT INTO `user` VALUES ('3', 'wtoip', 'wtoip', '18320706104', '数据团队', '0');

-- ----------------------------
-- Table structure for user_share
-- ----------------------------
DROP TABLE IF EXISTS `user_share`;
CREATE TABLE `user_share` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `user_name` varchar(255) DEFAULT NULL,
  `book_id` int(11) NOT NULL,
  `book_title` varchar(255) DEFAULT NULL,
  `reason` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '分享理由',
  `share_tiem` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '分享时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user_share
-- ----------------------------
INSERT INTO `user_share` VALUES ('17', '3', 'cjsong', '112', 'Java并发编程实战', '本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。', '2016-08-22 11:19:10');
INSERT INTO `user_share` VALUES ('19', '3', 'cjsong', '114', '数据结构与算法分析', '内容全面、缜密严格，并细致讲解精心构造程序的方法。', '2016-08-22 11:21:40');
INSERT INTO `user_share` VALUES ('20', '3', 'cjsong', '115', 'Android应用性能优化', '写出的应用就会更为健壮高效，从而广受用户好评，并最终获得成功。\n作者简介', '2016-08-22 11:22:45');
INSERT INTO `user_share` VALUES ('21', '3', 'cjsong', '116', 'PHP和MySQL Web开发(原书第4版)', '本书将PHP开发与MySQL应用相结合，分别对PHP和MySQL做了深入浅出的分析，不仅介绍PHP和MySQL的一般概念，而且对PHP和MySQL的Web应用做了较全面的阐述，并包括几个经典且实用的例子。', '2016-08-22 11:23:38');
INSERT INTO `user_share` VALUES ('22', '3', 'cjsong', '117', 'PHP核心技术与最佳实践', '系统归纳和深刻解读了PHP开发中的编程思想、底层原理、核心技术、开发技巧、编码规范和最佳实践。', '2016-08-22 11:24:28');
INSERT INTO `user_share` VALUES ('23', '3', 'cjsong', '118', '响应式Web设计', ' 本书堪称学习响应式Web设计的难得佳作。', '2016-08-22 11:25:21');
INSERT INTO `user_share` VALUES ('24', '3', 'cjsong', '119', 'HTML5权威指南', '系统学习网页设计的权威参考图书', '2016-08-22 11:27:38');
INSERT INTO `user_share` VALUES ('25', '3', 'cjsong', '120', '代码整洁之道', '软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。', '2016-08-22 11:29:03');
INSERT INTO `user_share` VALUES ('26', '3', 'cjsong', '121', '设计模式', '这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。', '2016-08-22 11:29:30');
INSERT INTO `user_share` VALUES ('27', '3', 'cjsong', '122', 'C程序设计语言', '在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。', '2016-08-22 11:29:55');
INSERT INTO `user_share` VALUES ('28', '3', 'cjsong', '123', 'Linux命令行与shell脚本编程大全', '本书是一本关于Linux 命令行与shell 脚本编程的全面教程。', '2016-08-22 11:30:29');
INSERT INTO `user_share` VALUES ('29', '3', 'cjsong', '124', 'Linux内核设计与实现(原书第3版)', '详细描述了Linux内核的设计与实现。', '2016-08-22 11:30:59');
INSERT INTO `user_share` VALUES ('30', '3', 'cjsong', '125', 'Node学习指南', 'node.js是一套用来编写高性能网络服务器的javascript工具包。', '2016-08-22 11:31:49');
INSERT INTO `user_share` VALUES ('32', '3', 'cjsong', '128', 'Node.js实战', ' Node.js及其扩展的安装配置； 全面理解异步编程和事件循环； 学会开发微博、聊天和游戏等热门应用。', '2016-08-22 11:34:04');
INSERT INTO `user_share` VALUES ('33', '3', 'cjsong', '130', 'Effective MySQL之备份与恢复', ' 使用压缩、流、增量和并行选项来优化备份方法 ；', '2016-08-22 11:35:30');
INSERT INTO `user_share` VALUES ('34', '3', 'cjsong', '132', '中文版Photoshop CS6平面广告设计', 'photoshop', '2016-08-22 11:40:50');
INSERT INTO `user_share` VALUES ('35', '3', 'cjsong', '133', 'HTML+CSS网页设计与布局从入门到精通', 'HTML+CSS网页设计与布局从入门到精通', '2016-08-22 11:41:28');
INSERT INTO `user_share` VALUES ('36', '3', 'cjsong', '135', 'ROS入门实例', '本书指导读者如何利用编程使机器人做一些神奇的事情。', '2016-08-22 11:46:19');
INSERT INTO `user_share` VALUES ('37', '3', 'cjsong', '136', '游戏人工智能编程案例精粹', '适合对游戏ai开发感兴趣的爱好者和游戏ai开发人员阅读和参考。', '2016-08-22 11:47:00');
